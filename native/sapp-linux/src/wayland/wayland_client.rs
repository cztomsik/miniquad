/* automatically generated by rust-bindgen 0.55.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 32;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const __GNUC_VA_LIST: u32 = 1;
pub const WAYLAND_VERSION_MAJOR: u32 = 1;
pub const WAYLAND_VERSION_MINOR: u32 = 18;
pub const WAYLAND_VERSION_MICRO: u32 = 0;
pub const WAYLAND_VERSION: &'static [u8; 7usize] = b"1.18.0\0";
pub const WL_DISPLAY_SYNC: u32 = 0;
pub const WL_DISPLAY_GET_REGISTRY: u32 = 1;
pub const WL_DISPLAY_ERROR_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_DELETE_ID_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_SYNC_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_GET_REGISTRY_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_BIND: u32 = 0;
pub const WL_REGISTRY_GLOBAL_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_GLOBAL_REMOVE_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_BIND_SINCE_VERSION: u32 = 1;
pub const WL_CALLBACK_DONE_SINCE_VERSION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_SURFACE: u32 = 0;
pub const WL_COMPOSITOR_CREATE_REGION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_SURFACE_SINCE_VERSION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_CREATE_BUFFER: u32 = 0;
pub const WL_SHM_POOL_DESTROY: u32 = 1;
pub const WL_SHM_POOL_RESIZE: u32 = 2;
pub const WL_SHM_POOL_CREATE_BUFFER_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_RESIZE_SINCE_VERSION: u32 = 1;
pub const WL_SHM_CREATE_POOL: u32 = 0;
pub const WL_SHM_FORMAT_SINCE_VERSION: u32 = 1;
pub const WL_SHM_CREATE_POOL_SINCE_VERSION: u32 = 1;
pub const WL_BUFFER_DESTROY: u32 = 0;
pub const WL_BUFFER_RELEASE_SINCE_VERSION: u32 = 1;
pub const WL_BUFFER_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_ACCEPT: u32 = 0;
pub const WL_DATA_OFFER_RECEIVE: u32 = 1;
pub const WL_DATA_OFFER_DESTROY: u32 = 2;
pub const WL_DATA_OFFER_FINISH: u32 = 3;
pub const WL_DATA_OFFER_SET_ACTIONS: u32 = 4;
pub const WL_DATA_OFFER_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_SOURCE_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_ACTION_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_ACCEPT_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_RECEIVE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_FINISH_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_SET_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_OFFER: u32 = 0;
pub const WL_DATA_SOURCE_DESTROY: u32 = 1;
pub const WL_DATA_SOURCE_SET_ACTIONS: u32 = 2;
pub const WL_DATA_SOURCE_TARGET_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_SEND_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_CANCELLED_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_DND_DROP_PERFORMED_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_DND_FINISHED_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_ACTION_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_SET_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_DEVICE_START_DRAG: u32 = 0;
pub const WL_DATA_DEVICE_SET_SELECTION: u32 = 1;
pub const WL_DATA_DEVICE_RELEASE: u32 = 2;
pub const WL_DATA_DEVICE_DATA_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_DROP_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_SELECTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_START_DRAG_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_SET_SELECTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_RELEASE_SINCE_VERSION: u32 = 2;
pub const WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE: u32 = 0;
pub const WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE: u32 = 1;
pub const WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_GET_SHELL_SURFACE: u32 = 0;
pub const WL_SHELL_GET_SHELL_SURFACE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_PONG: u32 = 0;
pub const WL_SHELL_SURFACE_MOVE: u32 = 1;
pub const WL_SHELL_SURFACE_RESIZE: u32 = 2;
pub const WL_SHELL_SURFACE_SET_TOPLEVEL: u32 = 3;
pub const WL_SHELL_SURFACE_SET_TRANSIENT: u32 = 4;
pub const WL_SHELL_SURFACE_SET_FULLSCREEN: u32 = 5;
pub const WL_SHELL_SURFACE_SET_POPUP: u32 = 6;
pub const WL_SHELL_SURFACE_SET_MAXIMIZED: u32 = 7;
pub const WL_SHELL_SURFACE_SET_TITLE: u32 = 8;
pub const WL_SHELL_SURFACE_SET_CLASS: u32 = 9;
pub const WL_SHELL_SURFACE_PING_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_POPUP_DONE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_PONG_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_MOVE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_RESIZE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TOPLEVEL_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TRANSIENT_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_FULLSCREEN_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_POPUP_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_MAXIMIZED_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TITLE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_CLASS_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_DESTROY: u32 = 0;
pub const WL_SURFACE_ATTACH: u32 = 1;
pub const WL_SURFACE_DAMAGE: u32 = 2;
pub const WL_SURFACE_FRAME: u32 = 3;
pub const WL_SURFACE_SET_OPAQUE_REGION: u32 = 4;
pub const WL_SURFACE_SET_INPUT_REGION: u32 = 5;
pub const WL_SURFACE_COMMIT: u32 = 6;
pub const WL_SURFACE_SET_BUFFER_TRANSFORM: u32 = 7;
pub const WL_SURFACE_SET_BUFFER_SCALE: u32 = 8;
pub const WL_SURFACE_DAMAGE_BUFFER: u32 = 9;
pub const WL_SURFACE_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_ATTACH_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_DAMAGE_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_FRAME_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_OPAQUE_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_INPUT_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_COMMIT_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_BUFFER_TRANSFORM_SINCE_VERSION: u32 = 2;
pub const WL_SURFACE_SET_BUFFER_SCALE_SINCE_VERSION: u32 = 3;
pub const WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION: u32 = 4;
pub const WL_SEAT_GET_POINTER: u32 = 0;
pub const WL_SEAT_GET_KEYBOARD: u32 = 1;
pub const WL_SEAT_GET_TOUCH: u32 = 2;
pub const WL_SEAT_RELEASE: u32 = 3;
pub const WL_SEAT_CAPABILITIES_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_NAME_SINCE_VERSION: u32 = 2;
pub const WL_SEAT_GET_POINTER_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_GET_KEYBOARD_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_GET_TOUCH_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_RELEASE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_SOURCE_WHEEL_TILT_SINCE_VERSION: u32 = 6;
pub const WL_POINTER_SET_CURSOR: u32 = 0;
pub const WL_POINTER_RELEASE: u32 = 1;
pub const WL_POINTER_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_BUTTON_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_AXIS_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_FRAME_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_SOURCE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_STOP_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_DISCRETE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_SET_CURSOR_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_KEYBOARD_RELEASE: u32 = 0;
pub const WL_KEYBOARD_KEYMAP_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_KEY_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_MODIFIERS_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_REPEAT_INFO_SINCE_VERSION: u32 = 4;
pub const WL_KEYBOARD_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_TOUCH_RELEASE: u32 = 0;
pub const WL_TOUCH_DOWN_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_UP_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_FRAME_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_CANCEL_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_SHAPE_SINCE_VERSION: u32 = 6;
pub const WL_TOUCH_ORIENTATION_SINCE_VERSION: u32 = 6;
pub const WL_TOUCH_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_OUTPUT_RELEASE: u32 = 0;
pub const WL_OUTPUT_GEOMETRY_SINCE_VERSION: u32 = 1;
pub const WL_OUTPUT_MODE_SINCE_VERSION: u32 = 1;
pub const WL_OUTPUT_DONE_SINCE_VERSION: u32 = 2;
pub const WL_OUTPUT_SCALE_SINCE_VERSION: u32 = 2;
pub const WL_OUTPUT_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_REGION_DESTROY: u32 = 0;
pub const WL_REGION_ADD: u32 = 1;
pub const WL_REGION_SUBTRACT: u32 = 2;
pub const WL_REGION_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_REGION_ADD_SINCE_VERSION: u32 = 1;
pub const WL_REGION_SUBTRACT_SINCE_VERSION: u32 = 1;
pub const WL_SUBCOMPOSITOR_DESTROY: u32 = 0;
pub const WL_SUBCOMPOSITOR_GET_SUBSURFACE: u32 = 1;
pub const WL_SUBCOMPOSITOR_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SUBCOMPOSITOR_GET_SUBSURFACE_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_DESTROY: u32 = 0;
pub const WL_SUBSURFACE_SET_POSITION: u32 = 1;
pub const WL_SUBSURFACE_PLACE_ABOVE: u32 = 2;
pub const WL_SUBSURFACE_PLACE_BELOW: u32 = 3;
pub const WL_SUBSURFACE_SET_SYNC: u32 = 4;
pub const WL_SUBSURFACE_SET_DESYNC: u32 = 5;
pub const WL_SUBSURFACE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_POSITION_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_PLACE_ABOVE_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_PLACE_BELOW_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_SYNC_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_DESYNC_SINCE_VERSION: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[doc = " \\class wl_object"]
#[doc = ""]
#[doc = " \\brief A protocol object."]
#[doc = ""]
#[doc = " A `wl_object` is an opaque struct identifying the protocol object"]
#[doc = " underlying a `wl_proxy` or `wl_resource`."]
#[doc = ""]
#[doc = " \\note Functions accessing a `wl_object` are not normally used by client code."]
#[doc = " Clients should normally use the higher level interface generated by the"]
#[doc = " scanner to interact with compositor objects."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_object {
    _unused: [u8; 0],
}
#[doc = " Protocol message signature"]
#[doc = ""]
#[doc = " A wl_message describes the signature of an actual protocol message, such as a"]
#[doc = " request or event, that adheres to the Wayland protocol wire format. The"]
#[doc = " protocol implementation uses a wl_message within its demarshal machinery for"]
#[doc = " decoding messages between a compositor and its clients. In a sense, a"]
#[doc = " wl_message is to a protocol message like a class is to an object."]
#[doc = ""]
#[doc = " The `name` of a wl_message is the name of the corresponding protocol message."]
#[doc = ""]
#[doc = " The `signature` is an ordered list of symbols representing the data types"]
#[doc = " of message arguments and, optionally, a protocol version and indicators for"]
#[doc = " nullability. A leading integer in the `signature` indicates the _since_"]
#[doc = " version of the protocol message. A `?` preceding a data type symbol indicates"]
#[doc = " that the following argument type is nullable. While it is a protocol violation"]
#[doc = " to send messages with non-nullable arguments set to `NULL`, event handlers in"]
#[doc = " clients might still get called with non-nullable object arguments set to"]
#[doc = " `NULL`. This can happen when the client destroyed the object being used as"]
#[doc = " argument on its side and an event referencing that object was sent before the"]
#[doc = " server knew about its destruction. As this race cannot be prevented, clients"]
#[doc = " should - as a general rule - program their event handlers such that they can"]
#[doc = " handle object arguments declared non-nullable being `NULL` gracefully."]
#[doc = ""]
#[doc = " When no arguments accompany a message, `signature` is an empty string."]
#[doc = ""]
#[doc = " Symbols:"]
#[doc = ""]
#[doc = " * `i`: int"]
#[doc = " * `u`: uint"]
#[doc = " * `f`: fixed"]
#[doc = " * `s`: string"]
#[doc = " * `o`: object"]
#[doc = " * `n`: new_id"]
#[doc = " * `a`: array"]
#[doc = " * `h`: fd"]
#[doc = " * `?`: following argument is nullable"]
#[doc = ""]
#[doc = " While demarshaling primitive arguments is straightforward, when demarshaling"]
#[doc = " messages containing `object` or `new_id` arguments, the protocol"]
#[doc = " implementation often must determine the type of the object. The `types` of a"]
#[doc = " wl_message is an array of wl_interface references that correspond to `o` and"]
#[doc = " `n` arguments in `signature`, with `NULL` placeholders for arguments with"]
#[doc = " non-object types."]
#[doc = ""]
#[doc = " Consider the protocol event wl_display `delete_id` that has a single `uint`"]
#[doc = " argument. The wl_message is:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " { \"delete_id\", \"u\", [NULL] }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " Here, the message `name` is `\"delete_id\"`, the `signature` is `\"u\"`, and the"]
#[doc = " argument `types` is `[NULL]`, indicating that the `uint` argument has no"]
#[doc = " corresponding wl_interface since it is a primitive argument."]
#[doc = ""]
#[doc = " In contrast, consider a `wl_foo` interface supporting protocol request `bar`"]
#[doc = " that has existed since version 2, and has two arguments: a `uint` and an"]
#[doc = " object of type `wl_baz_interface` that may be `NULL`. Such a `wl_message`"]
#[doc = " might be:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " { \"bar\", \"2u?o\", [NULL, &wl_baz_interface] }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " Here, the message `name` is `\"bar\"`, and the `signature` is `\"2u?o\"`. Notice"]
#[doc = " how the `2` indicates the protocol version, the `u` indicates the first"]
#[doc = " argument type is `uint`, and the `?o` indicates that the second argument"]
#[doc = " is an object that may be `NULL`. Lastly, the argument `types` array indicates"]
#[doc = " that no wl_interface corresponds to the first argument, while the type"]
#[doc = " `wl_baz_interface` corresponds to the second argument."]
#[doc = ""]
#[doc = " \\sa wl_argument"]
#[doc = " \\sa wl_interface"]
#[doc = " \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Wire-Format\">Wire Format</a>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_message {
    #[doc = " Message name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Message signature"]
    pub signature: *const ::std::os::raw::c_char,
    #[doc = " Object argument interfaces"]
    pub types: *mut *const wl_interface,
}
#[doc = " Protocol object interface"]
#[doc = ""]
#[doc = " A wl_interface describes the API of a protocol object defined in the Wayland"]
#[doc = " protocol specification. The protocol implementation uses a wl_interface"]
#[doc = " within its marshalling machinery for encoding client requests."]
#[doc = ""]
#[doc = " The `name` of a wl_interface is the name of the corresponding protocol"]
#[doc = " interface, and `version` represents the version of the interface. The members"]
#[doc = " `method_count` and `event_count` represent the number of `methods` (requests)"]
#[doc = " and `events` in the respective wl_message members."]
#[doc = ""]
#[doc = " For example, consider a protocol interface `foo`, marked as version `1`, with"]
#[doc = " two requests and one event."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " <interface name=\"foo\" version=\"1\">"]
#[doc = "   <request name=\"a\"></request>"]
#[doc = "   <request name=\"b\"></request>"]
#[doc = "   <event name=\"c\"></event>"]
#[doc = " </interface>"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " Given two wl_message arrays `foo_requests` and `foo_events`, a wl_interface"]
#[doc = " for `foo` might be:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " struct wl_interface foo_interface = {"]
#[doc = "         \"foo\", 1,"]
#[doc = "         2, foo_requests,"]
#[doc = "         1, foo_events"]
#[doc = " };"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note The server side of the protocol may define interface <em>implementation"]
#[doc = "       types</em> that incorporate the term `interface` in their name. Take"]
#[doc = "       care to not confuse these server-side `struct`s with a wl_interface"]
#[doc = "       variable whose name also ends in `interface`. For example, while the"]
#[doc = "       server may define a type `struct wl_foo_interface`, the client may"]
#[doc = "       define a `struct wl_interface wl_foo_interface`."]
#[doc = ""]
#[doc = " \\sa wl_message"]
#[doc = " \\sa wl_proxy"]
#[doc = " \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Interfaces\">Interfaces</a>"]
#[doc = " \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Versioning\">Versioning</a>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_interface {
    #[doc = " Interface name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Interface version"]
    pub version: ::std::os::raw::c_int,
    #[doc = " Number of methods (requests)"]
    pub method_count: ::std::os::raw::c_int,
    #[doc = " Method (request) signatures"]
    pub methods: *const wl_message,
    #[doc = " Number of events"]
    pub event_count: ::std::os::raw::c_int,
    #[doc = " Event signatures"]
    pub events: *const wl_message,
}
#[doc = " \\class wl_list"]
#[doc = ""]
#[doc = " \\brief Doubly-linked list"]
#[doc = ""]
#[doc = " On its own, an instance of `struct wl_list` represents the sentinel head of"]
#[doc = " a doubly-linked list, and must be initialized using wl_list_init()."]
#[doc = " When empty, the list head's `next` and `prev` members point to the list head"]
#[doc = " itself, otherwise `next` references the first element in the list, and `prev`"]
#[doc = " refers to the last element in the list."]
#[doc = ""]
#[doc = " Use the `struct wl_list` type to represent both the list head and the links"]
#[doc = " between elements within the list. Use wl_list_empty() to determine if the"]
#[doc = " list is empty in O(1)."]
#[doc = ""]
#[doc = " All elements in the list must be of the same type. The element type must have"]
#[doc = " a `struct wl_list` member, often named `link` by convention. Prior to"]
#[doc = " insertion, there is no need to initialize an element's `link` - invoking"]
#[doc = " wl_list_init() on an individual list element's `struct wl_list` member is"]
#[doc = " unnecessary if the very next operation is wl_list_insert(). However, a"]
#[doc = " common idiom is to initialize an element's `link` prior to removal - ensure"]
#[doc = " safety by invoking wl_list_init() before wl_list_remove()."]
#[doc = ""]
#[doc = " Consider a list reference `struct wl_list foo_list`, an element type as"]
#[doc = " `struct element`, and an element's link member as `struct wl_list link`."]
#[doc = ""]
#[doc = " The following code initializes a list and adds three elements to it."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " struct wl_list foo_list;"]
#[doc = ""]
#[doc = " struct element {"]
#[doc = "         int foo;"]
#[doc = "         struct wl_list link;"]
#[doc = " };"]
#[doc = " struct element e1, e2, e3;"]
#[doc = ""]
#[doc = " wl_list_init(&foo_list);"]
#[doc = " wl_list_insert(&foo_list, &e1.link);   // e1 is the first element"]
#[doc = " wl_list_insert(&foo_list, &e2.link);   // e2 is now the first element"]
#[doc = " wl_list_insert(&e2.link, &e3.link); // insert e3 after e2"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " The list now looks like <em>[e2, e3, e1]</em>."]
#[doc = ""]
#[doc = " The `wl_list` API provides some iterator macros. For example, to iterate"]
#[doc = " a list in ascending order:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " struct element *e;"]
#[doc = " wl_list_for_each(e, foo_list, link) {"]
#[doc = "         do_something_with_element(e);"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " See the documentation of each iterator for details."]
#[doc = " \\sa http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/list.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_list {
    #[doc = " Previous list element"]
    pub prev: *mut wl_list,
    #[doc = " Next list element"]
    pub next: *mut wl_list,
}
extern "C" {
    #[doc = " Initializes the list."]
    #[doc = ""]
    #[doc = " \\param list List to initialize"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_init(list: *mut wl_list);
}
extern "C" {
    #[doc = " Inserts an element into the list, after the element represented by \\p list."]
    #[doc = " When \\p list is a reference to the list itself (the head), set the containing"]
    #[doc = " struct of \\p elm as the first element in the list."]
    #[doc = ""]
    #[doc = " \\note If \\p elm is already part of a list, inserting it again will lead to"]
    #[doc = "       list corruption."]
    #[doc = ""]
    #[doc = " \\param list List element after which the new element is inserted"]
    #[doc = " \\param elm Link of the containing struct to insert into the list"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
}
extern "C" {
    #[doc = " Removes an element from the list."]
    #[doc = ""]
    #[doc = " \\note This operation leaves \\p elm in an invalid state."]
    #[doc = ""]
    #[doc = " \\param elm Link of the containing struct to remove from the list"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_remove(elm: *mut wl_list);
}
extern "C" {
    #[doc = " Determines the length of the list."]
    #[doc = ""]
    #[doc = " \\note This is an O(n) operation."]
    #[doc = ""]
    #[doc = " \\param list List whose length is to be determined"]
    #[doc = ""]
    #[doc = " \\return Number of elements in the list"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_length(list: *const wl_list) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determines if the list is empty."]
    #[doc = ""]
    #[doc = " \\param list List whose emptiness is to be determined"]
    #[doc = ""]
    #[doc = " \\return 1 if empty, or 0 if not empty"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_empty(list: *const wl_list) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inserts all of the elements of one list into another, after the element"]
    #[doc = " represented by \\p list."]
    #[doc = ""]
    #[doc = " \\note This leaves \\p other in an invalid state."]
    #[doc = ""]
    #[doc = " \\param list List element after which the other list elements will be inserted"]
    #[doc = " \\param other List of elements to insert"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_insert_list(list: *mut wl_list, other: *mut wl_list);
}
#[doc = " \\class wl_array"]
#[doc = ""]
#[doc = " Dynamic array"]
#[doc = ""]
#[doc = " A wl_array is a dynamic array that can only grow until released. It is"]
#[doc = " intended for relatively small allocations whose size is variable or not known"]
#[doc = " in advance. While construction of a wl_array does not require all elements to"]
#[doc = " be of the same size, wl_array_for_each() does require all elements to have"]
#[doc = " the same type and size."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_array {
    #[doc = " Array size"]
    pub size: size_t,
    #[doc = " Allocated space"]
    pub alloc: size_t,
    #[doc = " Array data"]
    pub data: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = " Initializes the array."]
    #[doc = ""]
    #[doc = " \\param array Array to initialize"]
    #[doc = ""]
    #[doc = " \\memberof wl_array"]
    pub fn wl_array_init(array: *mut wl_array);
}
extern "C" {
    #[doc = " Releases the array data."]
    #[doc = ""]
    #[doc = " \\note Leaves the array in an invalid state."]
    #[doc = ""]
    #[doc = " \\param array Array whose data is to be released"]
    #[doc = ""]
    #[doc = " \\memberof wl_array"]
    pub fn wl_array_release(array: *mut wl_array);
}
extern "C" {
    #[doc = " Increases the size of the array by \\p size bytes."]
    #[doc = ""]
    #[doc = " \\param array Array whose size is to be increased"]
    #[doc = " \\param size Number of bytes to increase the size of the array by"]
    #[doc = ""]
    #[doc = " \\return A pointer to the beginning of the newly appended space, or NULL when"]
    #[doc = "         resizing fails."]
    #[doc = ""]
    #[doc = " \\memberof wl_array"]
    pub fn wl_array_add(array: *mut wl_array, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Copies the contents of \\p source to \\p array."]
    #[doc = ""]
    #[doc = " \\param array Destination array to copy to"]
    #[doc = " \\param source Source array to copy from"]
    #[doc = ""]
    #[doc = " \\return 0 on success, or -1 on failure"]
    #[doc = ""]
    #[doc = " \\memberof wl_array"]
    pub fn wl_array_copy(array: *mut wl_array, source: *mut wl_array) -> ::std::os::raw::c_int;
}
#[doc = " Fixed-point number"]
#[doc = ""]
#[doc = " A `wl_fixed_t` is a 24.8 signed fixed-point number with a sign bit, 23 bits"]
#[doc = " of integer precision and 8 bits of decimal precision. Consider `wl_fixed_t`"]
#[doc = " as an opaque struct with methods that facilitate conversion to and from"]
#[doc = " `double` and `int` types."]
pub type wl_fixed_t = i32;
#[doc = " Protocol message argument data types"]
#[doc = ""]
#[doc = " This union represents all of the argument types in the Wayland protocol wire"]
#[doc = " format. The protocol implementation uses wl_argument within its marshalling"]
#[doc = " machinery for dispatching messages between a client and a compositor."]
#[doc = ""]
#[doc = " \\sa wl_message"]
#[doc = " \\sa wl_interface"]
#[doc = " \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-wire-Format\">Wire Format</a>"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wl_argument {
    #[doc = "< `int`"]
    pub i: i32,
    #[doc = "< `uint`"]
    pub u: u32,
    #[doc = "< `fixed`"]
    pub f: wl_fixed_t,
    #[doc = "< `string`"]
    pub s: *const ::std::os::raw::c_char,
    #[doc = "< `object`"]
    pub o: *mut wl_object,
    #[doc = "< `new_id`"]
    pub n: u32,
    #[doc = "< `array`"]
    pub a: *mut wl_array,
    #[doc = "< `fd`"]
    pub h: i32,
    _bindgen_union_align: u64,
}
#[doc = " Dispatcher function type alias"]
#[doc = ""]
#[doc = " A dispatcher is a function that handles the emitting of callbacks in client"]
#[doc = " code. For programs directly using the C library, this is done by using"]
#[doc = " libffi to call function pointers. When binding to languages other than C,"]
#[doc = " dispatchers provide a way to abstract the function calling process to be"]
#[doc = " friendlier to other function calling systems."]
#[doc = ""]
#[doc = " A dispatcher takes five arguments: The first is the dispatcher-specific"]
#[doc = " implementation associated with the target object. The second is the object"]
#[doc = " upon which the callback is being invoked (either wl_proxy or wl_resource)."]
#[doc = " The third and fourth arguments are the opcode and the wl_message"]
#[doc = " corresponding to the callback. The final argument is an array of arguments"]
#[doc = " received from the other process via the wire protocol."]
#[doc = ""]
#[doc = " \\param \"const void *\" Dispatcher-specific implementation data"]
#[doc = " \\param \"void *\" Callback invocation target (wl_proxy or `wl_resource`)"]
#[doc = " \\param uint32_t Callback opcode"]
#[doc = " \\param \"const struct wl_message *\" Callback message signature"]
#[doc = " \\param \"union wl_argument *\" Array of received arguments"]
#[doc = ""]
#[doc = " \\return 0 on success, or -1 on failure"]
pub type wl_dispatcher_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: u32,
        arg4: *const wl_message,
        arg5: *mut wl_argument,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Log function type alias"]
#[doc = ""]
#[doc = " The C implementation of the Wayland protocol abstracts the details of"]
#[doc = " logging. Users may customize the logging behavior, with a function conforming"]
#[doc = " to the `wl_log_func_t` type, via `wl_log_set_handler_client` and"]
#[doc = " `wl_log_set_handler_server`."]
#[doc = ""]
#[doc = " A `wl_log_func_t` must conform to the expectations of `vprintf`, and"]
#[doc = " expects two arguments: a string to write and a corresponding variable"]
#[doc = " argument list. While the string to write may contain format specifiers and"]
#[doc = " use values in the variable argument list, the behavior of any `wl_log_func_t`"]
#[doc = " depends on the implementation."]
#[doc = ""]
#[doc = " \\note Take care to not confuse this with `wl_protocol_logger_func_t`, which"]
#[doc = "       is a specific server-side logger for requests and events."]
#[doc = ""]
#[doc = " \\param \"const char *\" String to write to the log, containing optional format"]
#[doc = "                       specifiers"]
#[doc = " \\param \"va_list\" Variable argument list"]
#[doc = ""]
#[doc = " \\sa wl_log_set_handler_client"]
#[doc = " \\sa wl_log_set_handler_server"]
pub type wl_log_func_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: *mut __va_list_tag),
>;
#[doc = " Stop the iteration"]
pub const wl_iterator_result_WL_ITERATOR_STOP: wl_iterator_result = 0;
#[doc = " Continue the iteration"]
pub const wl_iterator_result_WL_ITERATOR_CONTINUE: wl_iterator_result = 1;
#[doc = " Return value of an iterator function"]
#[doc = ""]
#[doc = " \\sa wl_client_for_each_resource_iterator_func_t"]
#[doc = " \\sa wl_client_for_each_resource"]
pub type wl_iterator_result = ::std::os::raw::c_uint;
#[doc = " \\class wl_proxy"]
#[doc = ""]
#[doc = " \\brief Represents a protocol object on the client side."]
#[doc = ""]
#[doc = " A wl_proxy acts as a client side proxy to an object existing in the"]
#[doc = " compositor. The proxy is responsible for converting requests made by the"]
#[doc = " clients with \\ref wl_proxy_marshal() into Wayland's wire format. Events"]
#[doc = " coming from the compositor are also handled by the proxy, which will in"]
#[doc = " turn call the handler set with \\ref wl_proxy_add_listener()."]
#[doc = ""]
#[doc = " \\note With the exception of function \\ref wl_proxy_set_queue(), functions"]
#[doc = " accessing a wl_proxy are not normally used by client code. Clients"]
#[doc = " should normally use the higher level interface generated by the scanner to"]
#[doc = " interact with compositor objects."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_proxy {
    _unused: [u8; 0],
}
#[doc = " \\class wl_display"]
#[doc = ""]
#[doc = " \\brief Represents a connection to the compositor and acts as a proxy to"]
#[doc = " the wl_display singleton object."]
#[doc = ""]
#[doc = " A wl_display object represents a client connection to a Wayland"]
#[doc = " compositor. It is created with either \\ref wl_display_connect() or"]
#[doc = " \\ref wl_display_connect_to_fd(). A connection is terminated using"]
#[doc = " \\ref wl_display_disconnect()."]
#[doc = ""]
#[doc = " A wl_display is also used as the \\ref wl_proxy for the wl_display"]
#[doc = " singleton object on the compositor side."]
#[doc = ""]
#[doc = " A wl_display object handles all the data sent from and to the"]
#[doc = " compositor. When a \\ref wl_proxy marshals a request, it will write its wire"]
#[doc = " representation to the display's write buffer. The data is sent to the"]
#[doc = " compositor when the client calls \\ref wl_display_flush()."]
#[doc = ""]
#[doc = " Incoming data is handled in two steps: queueing and dispatching. In the"]
#[doc = " queue step, the data coming from the display fd is interpreted and"]
#[doc = " added to a queue. On the dispatch step, the handler for the incoming"]
#[doc = " event set by the client on the corresponding \\ref wl_proxy is called."]
#[doc = ""]
#[doc = " A wl_display has at least one event queue, called the <em>default"]
#[doc = " queue</em>. Clients can create additional event queues with \\ref"]
#[doc = " wl_display_create_queue() and assign \\ref wl_proxy's to it. Events"]
#[doc = " occurring in a particular proxy are always queued in its assigned queue."]
#[doc = " A client can ensure that a certain assumption, such as holding a lock"]
#[doc = " or running from a given thread, is true when a proxy event handler is"]
#[doc = " called by assigning that proxy to an event queue and making sure that"]
#[doc = " this queue is only dispatched when the assumption holds."]
#[doc = ""]
#[doc = " The default queue is dispatched by calling \\ref wl_display_dispatch()."]
#[doc = " This will dispatch any events queued on the default queue and attempt"]
#[doc = " to read from the display fd if it's empty. Events read are then queued"]
#[doc = " on the appropriate queues according to the proxy assignment."]
#[doc = ""]
#[doc = " A user created queue is dispatched with \\ref wl_display_dispatch_queue()."]
#[doc = " This function behaves exactly the same as wl_display_dispatch()"]
#[doc = " but it dispatches given queue instead of the default queue."]
#[doc = ""]
#[doc = " A real world example of event queue usage is Mesa's implementation of"]
#[doc = " eglSwapBuffers() for the Wayland platform. This function might need"]
#[doc = " to block until a frame callback is received, but dispatching the default"]
#[doc = " queue could cause an event handler on the client to start drawing"]
#[doc = " again. This problem is solved using another event queue, so that only"]
#[doc = " the events handled by the EGL code are dispatched during the block."]
#[doc = ""]
#[doc = " This creates a problem where a thread dispatches a non-default"]
#[doc = " queue, reading all the data from the display fd. If the application"]
#[doc = " would call \\em poll(2) after that it would block, even though there"]
#[doc = " might be events queued on the default queue. Those events should be"]
#[doc = " dispatched with \\ref wl_display_dispatch_pending() or \\ref"]
#[doc = " wl_display_dispatch_queue_pending() before flushing and blocking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display {
    _unused: [u8; 0],
}
#[doc = " \\class wl_event_queue"]
#[doc = ""]
#[doc = " \\brief A queue for \\ref wl_proxy object events."]
#[doc = ""]
#[doc = " Event queues allows the events on a display to be handled in a thread-safe"]
#[doc = " manner. See \\ref wl_display for details."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_event_queue {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_event_queue_destroy(queue: *mut wl_event_queue);
}
extern "C" {
    pub fn wl_proxy_marshal(p: *mut wl_proxy, opcode: u32, ...);
}
extern "C" {
    pub fn wl_proxy_marshal_array(p: *mut wl_proxy, opcode: u32, args: *mut wl_argument);
}
extern "C" {
    pub fn wl_proxy_create(factory: *mut wl_proxy, interface: *const wl_interface)
        -> *mut wl_proxy;
}
extern "C" {
    pub fn wl_proxy_create_wrapper(
        proxy: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_proxy_wrapper_destroy(proxy_wrapper: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wl_proxy_marshal_constructor(
        proxy: *mut wl_proxy,
        opcode: u32,
        interface: *const wl_interface,
        ...
    ) -> *mut wl_proxy;
}
extern "C" {
    pub fn wl_proxy_marshal_constructor_versioned(
        proxy: *mut wl_proxy,
        opcode: u32,
        interface: *const wl_interface,
        version: u32,
        ...
    ) -> *mut wl_proxy;
}
extern "C" {
    pub fn wl_proxy_marshal_array_constructor(
        proxy: *mut wl_proxy,
        opcode: u32,
        args: *mut wl_argument,
        interface: *const wl_interface,
    ) -> *mut wl_proxy;
}
extern "C" {
    pub fn wl_proxy_marshal_array_constructor_versioned(
        proxy: *mut wl_proxy,
        opcode: u32,
        args: *mut wl_argument,
        interface: *const wl_interface,
        version: u32,
    ) -> *mut wl_proxy;
}
extern "C" {
    pub fn wl_proxy_destroy(proxy: *mut wl_proxy);
}
extern "C" {
    pub fn wl_proxy_add_listener(
        proxy: *mut wl_proxy,
        implementation: *mut ::std::option::Option<unsafe extern "C" fn()>,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_proxy_get_listener(proxy: *mut wl_proxy) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_proxy_add_dispatcher(
        proxy: *mut wl_proxy,
        dispatcher_func: wl_dispatcher_func_t,
        dispatcher_data: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_proxy_set_user_data(proxy: *mut wl_proxy, user_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wl_proxy_get_user_data(proxy: *mut wl_proxy) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_proxy_get_version(proxy: *mut wl_proxy) -> u32;
}
extern "C" {
    pub fn wl_proxy_get_id(proxy: *mut wl_proxy) -> u32;
}
extern "C" {
    pub fn wl_proxy_set_tag(proxy: *mut wl_proxy, tag: *const *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn wl_proxy_get_tag(proxy: *mut wl_proxy) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wl_proxy_get_class(proxy: *mut wl_proxy) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wl_proxy_set_queue(proxy: *mut wl_proxy, queue: *mut wl_event_queue);
}
extern "C" {
    pub fn wl_display_connect(name: *const ::std::os::raw::c_char) -> *mut wl_display;
}
extern "C" {
    pub fn wl_display_connect_to_fd(fd: ::std::os::raw::c_int) -> *mut wl_display;
}
extern "C" {
    pub fn wl_display_disconnect(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_get_fd(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_dispatch(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_dispatch_queue(
        display: *mut wl_display,
        queue: *mut wl_event_queue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_dispatch_queue_pending(
        display: *mut wl_display,
        queue: *mut wl_event_queue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_dispatch_pending(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_get_error(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_get_protocol_error(
        display: *mut wl_display,
        interface: *mut *const wl_interface,
        id: *mut u32,
    ) -> u32;
}
extern "C" {
    pub fn wl_display_flush(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_roundtrip_queue(
        display: *mut wl_display,
        queue: *mut wl_event_queue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_roundtrip(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_create_queue(display: *mut wl_display) -> *mut wl_event_queue;
}
extern "C" {
    pub fn wl_display_prepare_read_queue(
        display: *mut wl_display,
        queue: *mut wl_event_queue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_prepare_read(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_cancel_read(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_read_events(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_log_set_handler_client(handler: wl_log_func_t);
}
#[doc = " @page page_wayland The wayland protocol"]
#[doc = " @section page_ifaces_wayland Interfaces"]
#[doc = " - @subpage page_iface_wl_display - core global object"]
#[doc = " - @subpage page_iface_wl_registry - global registry object"]
#[doc = " - @subpage page_iface_wl_callback - callback object"]
#[doc = " - @subpage page_iface_wl_compositor - the compositor singleton"]
#[doc = " - @subpage page_iface_wl_shm_pool - a shared memory pool"]
#[doc = " - @subpage page_iface_wl_shm - shared memory support"]
#[doc = " - @subpage page_iface_wl_buffer - content for a wl_surface"]
#[doc = " - @subpage page_iface_wl_data_offer - offer to transfer data"]
#[doc = " - @subpage page_iface_wl_data_source - offer to transfer data"]
#[doc = " - @subpage page_iface_wl_data_device - data transfer device"]
#[doc = " - @subpage page_iface_wl_data_device_manager - data transfer interface"]
#[doc = " - @subpage page_iface_wl_shell - create desktop-style surfaces"]
#[doc = " - @subpage page_iface_wl_shell_surface - desktop-style metadata interface"]
#[doc = " - @subpage page_iface_wl_surface - an onscreen surface"]
#[doc = " - @subpage page_iface_wl_seat - group of input devices"]
#[doc = " - @subpage page_iface_wl_pointer - pointer input device"]
#[doc = " - @subpage page_iface_wl_keyboard - keyboard input device"]
#[doc = " - @subpage page_iface_wl_touch - touchscreen input device"]
#[doc = " - @subpage page_iface_wl_output - compositor output region"]
#[doc = " - @subpage page_iface_wl_region - region interface"]
#[doc = " - @subpage page_iface_wl_subcompositor - sub-surface compositing"]
#[doc = " - @subpage page_iface_wl_subsurface - sub-surface interface to a wl_surface"]
#[doc = " @section page_copyright_wayland Copyright"]
#[doc = " <pre>"]
#[doc = ""]
#[doc = " Copyright © 2008-2011 Kristian Høgsberg"]
#[doc = " Copyright © 2010-2011 Intel Corporation"]
#[doc = " Copyright © 2012-2013 Collabora, Ltd."]
#[doc = ""]
#[doc = " Permission is hereby granted, free of charge, to any person"]
#[doc = " obtaining a copy of this software and associated documentation files"]
#[doc = " (the \"Software\"), to deal in the Software without restriction,"]
#[doc = " including without limitation the rights to use, copy, modify, merge,"]
#[doc = " publish, distribute, sublicense, and/or sell copies of the Software,"]
#[doc = " and to permit persons to whom the Software is furnished to do so,"]
#[doc = " subject to the following conditions:"]
#[doc = ""]
#[doc = " The above copyright notice and this permission notice (including the"]
#[doc = " next paragraph) shall be included in all copies or substantial"]
#[doc = " portions of the Software."]
#[doc = ""]
#[doc = " THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,"]
#[doc = " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF"]
#[doc = " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND"]
#[doc = " NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS"]
#[doc = " BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN"]
#[doc = " ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN"]
#[doc = " CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE"]
#[doc = " SOFTWARE."]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_compositor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_manager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_region {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subcompositor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subsurface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch {
    _unused: [u8; 0],
}
extern "C" {
    pub static wl_display_interface: wl_interface;
}
extern "C" {
    pub static wl_registry_interface: wl_interface;
}
extern "C" {
    pub static wl_callback_interface: wl_interface;
}
extern "C" {
    pub static wl_compositor_interface: wl_interface;
}
extern "C" {
    pub static wl_shm_pool_interface: wl_interface;
}
extern "C" {
    pub static wl_shm_interface: wl_interface;
}
extern "C" {
    pub static wl_buffer_interface: wl_interface;
}
extern "C" {
    pub static wl_data_offer_interface: wl_interface;
}
extern "C" {
    pub static wl_data_source_interface: wl_interface;
}
extern "C" {
    pub static wl_data_device_interface: wl_interface;
}
extern "C" {
    pub static wl_data_device_manager_interface: wl_interface;
}
extern "C" {
    pub static wl_shell_interface: wl_interface;
}
extern "C" {
    pub static wl_shell_surface_interface: wl_interface;
}
extern "C" {
    pub static wl_surface_interface: wl_interface;
}
extern "C" {
    pub static wl_seat_interface: wl_interface;
}
extern "C" {
    pub static wl_pointer_interface: wl_interface;
}
extern "C" {
    pub static wl_keyboard_interface: wl_interface;
}
extern "C" {
    pub static wl_touch_interface: wl_interface;
}
extern "C" {
    pub static wl_output_interface: wl_interface;
}
extern "C" {
    pub static wl_region_interface: wl_interface;
}
extern "C" {
    pub static wl_subcompositor_interface: wl_interface;
}
extern "C" {
    pub static wl_subsurface_interface: wl_interface;
}
#[doc = " server couldn't find object"]
pub const wl_display_error_WL_DISPLAY_ERROR_INVALID_OBJECT: wl_display_error = 0;
#[doc = " method doesn't exist on the specified interface or malformed request"]
pub const wl_display_error_WL_DISPLAY_ERROR_INVALID_METHOD: wl_display_error = 1;
#[doc = " server is out of memory"]
pub const wl_display_error_WL_DISPLAY_ERROR_NO_MEMORY: wl_display_error = 2;
#[doc = " implementation error in compositor"]
pub const wl_display_error_WL_DISPLAY_ERROR_IMPLEMENTATION: wl_display_error = 3;
#[doc = " @ingroup iface_wl_display"]
#[doc = " global error values"]
#[doc = ""]
#[doc = " These errors are global and can be emitted in response to any"]
#[doc = " server request."]
pub type wl_display_error = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_display"]
#[doc = " @struct wl_display_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display_listener {
    #[doc = " fatal error event"]
    #[doc = ""]
    #[doc = " The error event is sent out when a fatal (non-recoverable)"]
    #[doc = " error has occurred. The object_id argument is the object where"]
    #[doc = " the error occurred, most often in response to a request to that"]
    #[doc = " object. The code identifies the error and is defined by the"]
    #[doc = " object interface. As such, each interface defines its own set of"]
    #[doc = " error codes. The message is a brief description of the error,"]
    #[doc = " for (debugging) convenience."]
    #[doc = " @param object_id object where the error occurred"]
    #[doc = " @param code error code"]
    #[doc = " @param message error description"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_display: *mut wl_display,
            object_id: *mut ::std::os::raw::c_void,
            code: u32,
            message: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " acknowledge object ID deletion"]
    #[doc = ""]
    #[doc = " This event is used internally by the object ID management"]
    #[doc = " logic. When a client deletes an object that it had created, the"]
    #[doc = " server will send this event to acknowledge that it has seen the"]
    #[doc = " delete request. When the client receives this event, it will"]
    #[doc = " know that it can safely reuse the object ID."]
    #[doc = " @param id deleted object ID"]
    pub delete_id: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_display: *mut wl_display,
            id: u32,
        ),
    >,
}
#[doc = " @ingroup iface_wl_registry"]
#[doc = " @struct wl_registry_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry_listener {
    #[doc = " announce global object"]
    #[doc = ""]
    #[doc = " Notify the client of global objects."]
    #[doc = ""]
    #[doc = " The event notifies the client that a global object with the"]
    #[doc = " given name is now available, and it implements the given version"]
    #[doc = " of the given interface."]
    #[doc = " @param name numeric name of the global object"]
    #[doc = " @param interface interface implemented by the object"]
    #[doc = " @param version interface version"]
    pub global: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_registry: *mut wl_registry,
            name: u32,
            interface: *const ::std::os::raw::c_char,
            version: u32,
        ),
    >,
    #[doc = " announce removal of global object"]
    #[doc = ""]
    #[doc = " Notify the client of removed global objects."]
    #[doc = ""]
    #[doc = " This event notifies the client that the global identified by"]
    #[doc = " name is no longer available. If the client bound to the global"]
    #[doc = " using the bind request, the client should now destroy that"]
    #[doc = " object."]
    #[doc = ""]
    #[doc = " The object remains valid and requests to the object will be"]
    #[doc = " ignored until the client destroys it, to avoid races between the"]
    #[doc = " global going away and a client sending a request to it."]
    #[doc = " @param name numeric name of the global object"]
    pub global_remove: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_registry: *mut wl_registry,
            name: u32,
        ),
    >,
}
#[doc = " @ingroup iface_wl_callback"]
#[doc = " @struct wl_callback_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_callback_listener {
    #[doc = " done event"]
    #[doc = ""]
    #[doc = " Notify the client when the related request is done."]
    #[doc = " @param callback_data request-specific data for the callback"]
    pub done: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_callback: *mut wl_callback,
            callback_data: u32,
        ),
    >,
}
#[doc = " buffer format is not known"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_FORMAT: wl_shm_error = 0;
#[doc = " invalid size or stride during pool or buffer creation"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_STRIDE: wl_shm_error = 1;
#[doc = " mmapping the file descriptor failed"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_FD: wl_shm_error = 2;
#[doc = " @ingroup iface_wl_shm"]
#[doc = " wl_shm error values"]
#[doc = ""]
#[doc = " These errors can be emitted in response to wl_shm requests."]
pub type wl_shm_error = ::std::os::raw::c_uint;
#[doc = " 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
#[doc = " 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
#[doc = " 8-bit color index format, [7:0] C"]
pub const wl_shm_format_WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
#[doc = " 8-bit RGB format, [7:0] R:G:B 3:3:2"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
#[doc = " 8-bit BGR format, [7:0] B:G:R 2:3:3"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
#[doc = " 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
#[doc = " 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
#[doc = " 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
#[doc = " 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
#[doc = " 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
#[doc = " 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
#[doc = " 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
#[doc = " 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
#[doc = " 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
#[doc = " 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
#[doc = " 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
#[doc = " 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
#[doc = " 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
#[doc = " 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
#[doc = " 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
#[doc = " 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
#[doc = " 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
#[doc = " 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
#[doc = " 24-bit RGB format, [23:0] R:G:B little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
#[doc = " 24-bit BGR format, [23:0] B:G:R little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
#[doc = " 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
#[doc = " 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
#[doc = " 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
#[doc = " 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
#[doc = " 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
#[doc = " 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
#[doc = " 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
#[doc = " 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
#[doc = " 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
#[doc = " 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
#[doc = " 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
#[doc = " 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
#[doc = " 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
#[doc = " 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
#[doc = " packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
#[doc = " packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
#[doc = " packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
#[doc = " packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
#[doc = " packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
#[doc = " 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
#[doc = " 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
#[doc = " 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
#[doc = " 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
#[doc = " 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
#[doc = " 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
#[doc = " 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
#[doc = " 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
#[doc = " 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
#[doc = " 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
#[doc = " 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
#[doc = " 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
#[doc = " 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
#[doc = " 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
#[doc = " [7:0] R"]
pub const wl_shm_format_WL_SHM_FORMAT_R8: wl_shm_format = 538982482;
#[doc = " [15:0] R little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_R16: wl_shm_format = 540422482;
#[doc = " [15:0] R:G 8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RG88: wl_shm_format = 943212370;
#[doc = " [15:0] G:R 8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_GR88: wl_shm_format = 943215175;
#[doc = " [31:0] R:G 16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RG1616: wl_shm_format = 842221394;
#[doc = " [31:0] G:R 16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_GR1616: wl_shm_format = 842224199;
#[doc = " [63:0] x:R:G:B 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB16161616F: wl_shm_format = 1211388504;
#[doc = " [63:0] x:B:G:R 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR16161616F: wl_shm_format = 1211384408;
#[doc = " [63:0] A:R:G:B 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB16161616F: wl_shm_format = 1211388481;
#[doc = " [63:0] A:B:G:R 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR16161616F: wl_shm_format = 1211384385;
#[doc = " [31:0] X:Y:Cb:Cr 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XYUV8888: wl_shm_format = 1448434008;
#[doc = " [23:0] Cr:Cb:Y 8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_VUY888: wl_shm_format = 875713878;
#[doc = " Y followed by U then V, 10:10:10. Non-linear modifier only"]
pub const wl_shm_format_WL_SHM_FORMAT_VUY101010: wl_shm_format = 808670550;
#[doc = " [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y210: wl_shm_format = 808530521;
#[doc = " [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y212: wl_shm_format = 842084953;
#[doc = " [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y216: wl_shm_format = 909193817;
#[doc = " [31:0] A:Cr:Y:Cb 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y410: wl_shm_format = 808531033;
#[doc = " [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y412: wl_shm_format = 842085465;
#[doc = " [63:0] A:Cr:Y:Cb 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y416: wl_shm_format = 909194329;
#[doc = " [31:0] X:Cr:Y:Cb 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU2101010: wl_shm_format = 808670808;
#[doc = " [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU12_16161616: wl_shm_format = 909334104;
#[doc = " [63:0] X:Cr:Y:Cb 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU16161616: wl_shm_format = 942954072;
#[doc = " [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y0L0: wl_shm_format = 810299481;
#[doc = " [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_X0L0: wl_shm_format = 810299480;
#[doc = " [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y0L2: wl_shm_format = 843853913;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_X0L2: wl_shm_format = 843853912;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420_8BIT: wl_shm_format = 942691673;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420_10BIT: wl_shm_format = 808539481;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB8888_A8: wl_shm_format = 943805016;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR8888_A8: wl_shm_format = 943800920;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX8888_A8: wl_shm_format = 943806546;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX8888_A8: wl_shm_format = 943806530;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB888_A8: wl_shm_format = 943798354;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR888_A8: wl_shm_format = 943798338;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB565_A8: wl_shm_format = 943797586;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR565_A8: wl_shm_format = 943797570;
#[doc = " non-subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV24: wl_shm_format = 875714126;
#[doc = " non-subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV42: wl_shm_format = 842290766;
#[doc = " 2x1 subsampled Cr:Cb plane, 10 bit per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P210: wl_shm_format = 808530512;
#[doc = " 2x2 subsampled Cr:Cb plane 10 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P010: wl_shm_format = 808530000;
#[doc = " 2x2 subsampled Cr:Cb plane 12 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P012: wl_shm_format = 842084432;
#[doc = " 2x2 subsampled Cr:Cb plane 16 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P016: wl_shm_format = 909193296;
#[doc = " @ingroup iface_wl_shm"]
#[doc = " pixel formats"]
#[doc = ""]
#[doc = " This describes the memory layout of an individual pixel."]
#[doc = ""]
#[doc = " All renderers should support argb8888 and xrgb8888 but any other"]
#[doc = " formats are optional and may not be supported by the particular"]
#[doc = " renderer in use."]
#[doc = ""]
#[doc = " The drm format codes match the macros defined in drm_fourcc.h, except"]
#[doc = " argb8888 and xrgb8888. The formats actually supported by the compositor"]
#[doc = " will be reported by the format event."]
pub type wl_shm_format = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_shm"]
#[doc = " @struct wl_shm_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_listener {
    #[doc = " pixel format description"]
    #[doc = ""]
    #[doc = " Informs the client about a valid pixel format that can be used"]
    #[doc = " for buffers. Known formats include argb8888 and xrgb8888."]
    #[doc = " @param format buffer pixel format"]
    pub format: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_shm: *mut wl_shm, format: u32),
    >,
}
#[doc = " @ingroup iface_wl_buffer"]
#[doc = " @struct wl_buffer_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer_listener {
    #[doc = " compositor releases buffer"]
    #[doc = ""]
    #[doc = " Sent when this wl_buffer is no longer used by the compositor."]
    #[doc = " The client is now free to reuse or destroy this buffer and its"]
    #[doc = " backing storage."]
    #[doc = ""]
    #[doc = " If a client receives a release event before the frame callback"]
    #[doc = " requested in the same wl_surface.commit that attaches this"]
    #[doc = " wl_buffer to a surface, then the client is immediately free to"]
    #[doc = " reuse the buffer and its backing storage, and does not need a"]
    #[doc = " second buffer for the next surface content update. Typically"]
    #[doc = " this is possible, when the compositor maintains a copy of the"]
    #[doc = " wl_surface contents, e.g. as a GL texture. This is an important"]
    #[doc = " optimization for GL(ES) compositors with wl_shm clients."]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_buffer: *mut wl_buffer),
    >,
}
#[doc = " finish request was called untimely"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_FINISH: wl_data_offer_error = 0;
#[doc = " action mask contains invalid values"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK: wl_data_offer_error = 1;
#[doc = " action argument has an invalid value"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_ACTION: wl_data_offer_error = 2;
#[doc = " offer doesn't accept this request"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_OFFER: wl_data_offer_error = 3;
pub type wl_data_offer_error = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_data_offer"]
#[doc = " @struct wl_data_offer_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer_listener {
    #[doc = " advertise offered mime type"]
    #[doc = ""]
    #[doc = " Sent immediately after creating the wl_data_offer object. One"]
    #[doc = " event per offered mime type."]
    #[doc = " @param mime_type offered mime type"]
    pub offer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_offer: *mut wl_data_offer,
            mime_type: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " notify the source-side available actions"]
    #[doc = ""]
    #[doc = " This event indicates the actions offered by the data source."]
    #[doc = " It will be sent right after wl_data_device.enter, or anytime the"]
    #[doc = " source side changes its offered actions through"]
    #[doc = " wl_data_source.set_actions."]
    #[doc = " @param source_actions actions offered by the data source"]
    #[doc = " @since 3"]
    pub source_actions: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_offer: *mut wl_data_offer,
            source_actions: u32,
        ),
    >,
    #[doc = " notify the selected action"]
    #[doc = ""]
    #[doc = " This event indicates the action selected by the compositor"]
    #[doc = " after matching the source/destination side actions. Only one"]
    #[doc = " action (or none) will be offered here."]
    #[doc = ""]
    #[doc = " This event can be emitted multiple times during the"]
    #[doc = " drag-and-drop operation in response to destination side action"]
    #[doc = " changes through wl_data_offer.set_actions."]
    #[doc = ""]
    #[doc = " This event will no longer be emitted after wl_data_device.drop"]
    #[doc = " happened on the drag-and-drop destination, the client must honor"]
    #[doc = " the last action received, or the last preferred one set through"]
    #[doc = " wl_data_offer.set_actions when handling an \"ask\" action."]
    #[doc = ""]
    #[doc = " Compositors may also change the selected action on the fly,"]
    #[doc = " mainly in response to keyboard modifier changes during the"]
    #[doc = " drag-and-drop operation."]
    #[doc = ""]
    #[doc = " The most recent action received is always the valid one. Prior"]
    #[doc = " to receiving wl_data_device.drop, the chosen action may change"]
    #[doc = " (e.g. due to keyboard modifiers being pressed). At the time of"]
    #[doc = " receiving wl_data_device.drop the drag-and-drop destination must"]
    #[doc = " honor the last action received."]
    #[doc = ""]
    #[doc = " Action changes may still happen after wl_data_device.drop,"]
    #[doc = " especially on \"ask\" actions, where the drag-and-drop destination"]
    #[doc = " may choose another action afterwards. Action changes happening"]
    #[doc = " at this stage are always the result of inter-client negotiation,"]
    #[doc = " the compositor shall no longer be able to induce a different"]
    #[doc = " action."]
    #[doc = ""]
    #[doc = " Upon \"ask\" actions, it is expected that the drag-and-drop"]
    #[doc = " destination may potentially choose a different action and/or"]
    #[doc = " mime type, based on wl_data_offer.source_actions and finally"]
    #[doc = " chosen by the user (e.g. popping up a menu with the available"]
    #[doc = " options). The final wl_data_offer.set_actions and"]
    #[doc = " wl_data_offer.accept requests must happen before the call to"]
    #[doc = " wl_data_offer.finish."]
    #[doc = " @param dnd_action action selected by the compositor"]
    #[doc = " @since 3"]
    pub action: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_offer: *mut wl_data_offer,
            dnd_action: u32,
        ),
    >,
}
#[doc = " action mask contains invalid values"]
pub const wl_data_source_error_WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK: wl_data_source_error = 0;
#[doc = " source doesn't accept this request"]
pub const wl_data_source_error_WL_DATA_SOURCE_ERROR_INVALID_SOURCE: wl_data_source_error = 1;
pub type wl_data_source_error = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_data_source"]
#[doc = " @struct wl_data_source_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source_listener {
    #[doc = " a target accepts an offered mime type"]
    #[doc = ""]
    #[doc = " Sent when a target accepts pointer_focus or motion events. If"]
    #[doc = " a target does not accept any of the offered types, type is NULL."]
    #[doc = ""]
    #[doc = " Used for feedback during drag-and-drop."]
    #[doc = " @param mime_type mime type accepted by the target"]
    pub target: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_source: *mut wl_data_source,
            mime_type: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " send the data"]
    #[doc = ""]
    #[doc = " Request for data from the client. Send the data as the"]
    #[doc = " specified mime type over the passed file descriptor, then close"]
    #[doc = " it."]
    #[doc = " @param mime_type mime type for the data"]
    #[doc = " @param fd file descriptor for the data"]
    pub send: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_source: *mut wl_data_source,
            mime_type: *const ::std::os::raw::c_char,
            fd: i32,
        ),
    >,
    #[doc = " selection was cancelled"]
    #[doc = ""]
    #[doc = " This data source is no longer valid. There are several reasons"]
    #[doc = " why this could happen:"]
    #[doc = ""]
    #[doc = " - The data source has been replaced by another data source. -"]
    #[doc = " The drag-and-drop operation was performed, but the drop"]
    #[doc = " destination did not accept any of the mime types offered through"]
    #[doc = " wl_data_source.target. - The drag-and-drop operation was"]
    #[doc = " performed, but the drop destination did not select any of the"]
    #[doc = " actions present in the mask offered through"]
    #[doc = " wl_data_source.action. - The drag-and-drop operation was"]
    #[doc = " performed but didn't happen over a surface. - The compositor"]
    #[doc = " cancelled the drag-and-drop operation (e.g. compositor dependent"]
    #[doc = " timeouts to avoid stale drag-and-drop transfers)."]
    #[doc = ""]
    #[doc = " The client should clean up and destroy this data source."]
    #[doc = ""]
    #[doc = " For objects of version 2 or older, wl_data_source.cancelled will"]
    #[doc = " only be emitted if the data source was replaced by another data"]
    #[doc = " source."]
    pub cancelled: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_source: *mut wl_data_source,
        ),
    >,
    #[doc = " the drag-and-drop operation physically finished"]
    #[doc = ""]
    #[doc = " The user performed the drop action. This event does not"]
    #[doc = " indicate acceptance, wl_data_source.cancelled may still be"]
    #[doc = " emitted afterwards if the drop destination does not accept any"]
    #[doc = " mime type."]
    #[doc = ""]
    #[doc = " However, this event might however not be received if the"]
    #[doc = " compositor cancelled the drag-and-drop operation before this"]
    #[doc = " event could happen."]
    #[doc = ""]
    #[doc = " Note that the data_source may still be used in the future and"]
    #[doc = " should not be destroyed here."]
    #[doc = " @since 3"]
    pub dnd_drop_performed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_source: *mut wl_data_source,
        ),
    >,
    #[doc = " the drag-and-drop operation concluded"]
    #[doc = ""]
    #[doc = " The drop destination finished interoperating with this data"]
    #[doc = " source, so the client is now free to destroy this data source"]
    #[doc = " and free all associated data."]
    #[doc = ""]
    #[doc = " If the action used to perform the operation was \"move\", the"]
    #[doc = " source can now delete the transferred data."]
    #[doc = " @since 3"]
    pub dnd_finished: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_source: *mut wl_data_source,
        ),
    >,
    #[doc = " notify the selected action"]
    #[doc = ""]
    #[doc = " This event indicates the action selected by the compositor"]
    #[doc = " after matching the source/destination side actions. Only one"]
    #[doc = " action (or none) will be offered here."]
    #[doc = ""]
    #[doc = " This event can be emitted multiple times during the"]
    #[doc = " drag-and-drop operation, mainly in response to destination side"]
    #[doc = " changes through wl_data_offer.set_actions, and as the data"]
    #[doc = " device enters/leaves surfaces."]
    #[doc = ""]
    #[doc = " It is only possible to receive this event after"]
    #[doc = " wl_data_source.dnd_drop_performed if the drag-and-drop operation"]
    #[doc = " ended in an \"ask\" action, in which case the final"]
    #[doc = " wl_data_source.action event will happen immediately before"]
    #[doc = " wl_data_source.dnd_finished."]
    #[doc = ""]
    #[doc = " Compositors may also change the selected action on the fly,"]
    #[doc = " mainly in response to keyboard modifier changes during the"]
    #[doc = " drag-and-drop operation."]
    #[doc = ""]
    #[doc = " The most recent action received is always the valid one. The"]
    #[doc = " chosen action may change alongside negotiation (e.g. an \"ask\""]
    #[doc = " action can turn into a \"move\" operation), so the effects of the"]
    #[doc = " final action must always be applied in"]
    #[doc = " wl_data_offer.dnd_finished."]
    #[doc = ""]
    #[doc = " Clients can trigger cursor surface changes from this point, so"]
    #[doc = " they reflect the current action."]
    #[doc = " @param dnd_action action selected by the compositor"]
    #[doc = " @since 3"]
    pub action: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_source: *mut wl_data_source,
            dnd_action: u32,
        ),
    >,
}
#[doc = " given wl_surface has another role"]
pub const wl_data_device_error_WL_DATA_DEVICE_ERROR_ROLE: wl_data_device_error = 0;
pub type wl_data_device_error = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_data_device"]
#[doc = " @struct wl_data_device_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_listener {
    #[doc = " introduce a new wl_data_offer"]
    #[doc = ""]
    #[doc = " The data_offer event introduces a new wl_data_offer object,"]
    #[doc = " which will subsequently be used in either the data_device.enter"]
    #[doc = " event (for drag-and-drop) or the data_device.selection event"]
    #[doc = " (for selections). Immediately following the"]
    #[doc = " data_device_data_offer event, the new data_offer object will"]
    #[doc = " send out data_offer.offer events to describe the mime types it"]
    #[doc = " offers."]
    #[doc = " @param id the new data_offer object"]
    pub data_offer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_device: *mut wl_data_device,
            id: *mut wl_data_offer,
        ),
    >,
    #[doc = " initiate drag-and-drop session"]
    #[doc = ""]
    #[doc = " This event is sent when an active drag-and-drop pointer enters"]
    #[doc = " a surface owned by the client. The position of the pointer at"]
    #[doc = " enter time is provided by the x and y arguments, in"]
    #[doc = " surface-local coordinates."]
    #[doc = " @param serial serial number of the enter event"]
    #[doc = " @param surface client surface entered"]
    #[doc = " @param x surface-local x coordinate"]
    #[doc = " @param y surface-local y coordinate"]
    #[doc = " @param id source data_offer object"]
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_device: *mut wl_data_device,
            serial: u32,
            surface: *mut wl_surface,
            x: wl_fixed_t,
            y: wl_fixed_t,
            id: *mut wl_data_offer,
        ),
    >,
    #[doc = " end drag-and-drop session"]
    #[doc = ""]
    #[doc = " This event is sent when the drag-and-drop pointer leaves the"]
    #[doc = " surface and the session ends. The client must destroy the"]
    #[doc = " wl_data_offer introduced at enter time at this point."]
    pub leave: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_device: *mut wl_data_device,
        ),
    >,
    #[doc = " drag-and-drop session motion"]
    #[doc = ""]
    #[doc = " This event is sent when the drag-and-drop pointer moves within"]
    #[doc = " the currently focused surface. The new position of the pointer"]
    #[doc = " is provided by the x and y arguments, in surface-local"]
    #[doc = " coordinates."]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param x surface-local x coordinate"]
    #[doc = " @param y surface-local y coordinate"]
    pub motion: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_device: *mut wl_data_device,
            time: u32,
            x: wl_fixed_t,
            y: wl_fixed_t,
        ),
    >,
    #[doc = " end drag-and-drop session successfully"]
    #[doc = ""]
    #[doc = " The event is sent when a drag-and-drop operation is ended"]
    #[doc = " because the implicit grab is removed."]
    #[doc = ""]
    #[doc = " The drag-and-drop destination is expected to honor the last"]
    #[doc = " action received through wl_data_offer.action, if the resulting"]
    #[doc = " action is \"copy\" or \"move\", the destination can still perform"]
    #[doc = " wl_data_offer.receive requests, and is expected to end all"]
    #[doc = " transfers with a wl_data_offer.finish request."]
    #[doc = ""]
    #[doc = " If the resulting action is \"ask\", the action will not be"]
    #[doc = " considered final. The drag-and-drop destination is expected to"]
    #[doc = " perform one last wl_data_offer.set_actions request, or"]
    #[doc = " wl_data_offer.destroy in order to cancel the operation."]
    pub drop: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_device: *mut wl_data_device,
        ),
    >,
    #[doc = " advertise new selection"]
    #[doc = ""]
    #[doc = " The selection event is sent out to notify the client of a new"]
    #[doc = " wl_data_offer for the selection for this device. The"]
    #[doc = " data_device.data_offer and the data_offer.offer events are sent"]
    #[doc = " out immediately before this event to introduce the data offer"]
    #[doc = " object. The selection event is sent to a client immediately"]
    #[doc = " before receiving keyboard focus and when a new selection is set"]
    #[doc = " while the client has keyboard focus. The data_offer is valid"]
    #[doc = " until a new data_offer or NULL is received or until the client"]
    #[doc = " loses keyboard focus. The client must destroy the previous"]
    #[doc = " selection data_offer, if any, upon receiving this event."]
    #[doc = " @param id selection data_offer object"]
    pub selection: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_data_device: *mut wl_data_device,
            id: *mut wl_data_offer,
        ),
    >,
}
#[doc = " no action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE:
    wl_data_device_manager_dnd_action = 0;
#[doc = " copy action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY:
    wl_data_device_manager_dnd_action = 1;
#[doc = " move action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE:
    wl_data_device_manager_dnd_action = 2;
#[doc = " ask action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK:
    wl_data_device_manager_dnd_action = 4;
#[doc = " @ingroup iface_wl_data_device_manager"]
#[doc = " drag and drop actions"]
#[doc = ""]
#[doc = " This is a bitmask of the available/preferred actions in a"]
#[doc = " drag-and-drop operation."]
#[doc = ""]
#[doc = " In the compositor, the selected action is a result of matching the"]
#[doc = " actions offered by the source and destination sides.  \"action\" events"]
#[doc = " with a \"none\" action will be sent to both source and destination if"]
#[doc = " there is no match. All further checks will effectively happen on"]
#[doc = " (source actions ∩ destination actions)."]
#[doc = ""]
#[doc = " In addition, compositors may also pick different actions in"]
#[doc = " reaction to key modifiers being pressed. One common design that"]
#[doc = " is used in major toolkits (and the behavior recommended for"]
#[doc = " compositors) is:"]
#[doc = ""]
#[doc = " - If no modifiers are pressed, the first match (in bit order)"]
#[doc = " will be used."]
#[doc = " - Pressing Shift selects \"move\", if enabled in the mask."]
#[doc = " - Pressing Control selects \"copy\", if enabled in the mask."]
#[doc = ""]
#[doc = " Behavior beyond that is considered implementation-dependent."]
#[doc = " Compositors may for example bind other modifiers (like Alt/Meta)"]
#[doc = " or drags initiated with other buttons than BTN_LEFT to specific"]
#[doc = " actions (e.g. \"ask\")."]
pub type wl_data_device_manager_dnd_action = ::std::os::raw::c_uint;
#[doc = " given wl_surface has another role"]
pub const wl_shell_error_WL_SHELL_ERROR_ROLE: wl_shell_error = 0;
pub type wl_shell_error = ::std::os::raw::c_uint;
#[doc = " no edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_NONE: wl_shell_surface_resize = 0;
#[doc = " top edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP: wl_shell_surface_resize = 1;
#[doc = " bottom edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM: wl_shell_surface_resize = 2;
#[doc = " left edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_LEFT: wl_shell_surface_resize = 4;
#[doc = " top and left edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP_LEFT: wl_shell_surface_resize = 5;
#[doc = " bottom and left edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT: wl_shell_surface_resize = 6;
#[doc = " right edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_RIGHT: wl_shell_surface_resize = 8;
#[doc = " top and right edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP_RIGHT: wl_shell_surface_resize = 9;
#[doc = " bottom and right edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT: wl_shell_surface_resize =
    10;
#[doc = " @ingroup iface_wl_shell_surface"]
#[doc = " edge values for resizing"]
#[doc = ""]
#[doc = " These values are used to indicate which edge of a surface"]
#[doc = " is being dragged in a resize operation. The server may"]
#[doc = " use this information to adapt its behavior, e.g. choose"]
#[doc = " an appropriate cursor image."]
pub type wl_shell_surface_resize = ::std::os::raw::c_uint;
#[doc = " do not set keyboard focus"]
pub const wl_shell_surface_transient_WL_SHELL_SURFACE_TRANSIENT_INACTIVE:
    wl_shell_surface_transient = 1;
#[doc = " @ingroup iface_wl_shell_surface"]
#[doc = " details of transient behaviour"]
#[doc = ""]
#[doc = " These flags specify details of the expected behaviour"]
#[doc = " of transient surfaces. Used in the set_transient request."]
pub type wl_shell_surface_transient = ::std::os::raw::c_uint;
#[doc = " no preference, apply default policy"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT:
    wl_shell_surface_fullscreen_method = 0;
#[doc = " scale, preserve the surface's aspect ratio and center on output"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE:
    wl_shell_surface_fullscreen_method = 1;
#[doc = " switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER:
    wl_shell_surface_fullscreen_method = 2;
#[doc = " no upscaling, center on output and add black borders to compensate size mismatch"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL:
    wl_shell_surface_fullscreen_method = 3;
#[doc = " @ingroup iface_wl_shell_surface"]
#[doc = " different method to set the surface fullscreen"]
#[doc = ""]
#[doc = " Hints to indicate to the compositor how to deal with a conflict"]
#[doc = " between the dimensions of the surface and the dimensions of the"]
#[doc = " output. The compositor is free to ignore this parameter."]
pub type wl_shell_surface_fullscreen_method = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_shell_surface"]
#[doc = " @struct wl_shell_surface_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface_listener {
    #[doc = " ping client"]
    #[doc = ""]
    #[doc = " Ping a client to check if it is receiving events and sending"]
    #[doc = " requests. A client is expected to reply with a pong request."]
    #[doc = " @param serial serial number of the ping"]
    pub ping: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_shell_surface: *mut wl_shell_surface,
            serial: u32,
        ),
    >,
    #[doc = " suggest resize"]
    #[doc = ""]
    #[doc = " The configure event asks the client to resize its surface."]
    #[doc = ""]
    #[doc = " The size is a hint, in the sense that the client is free to"]
    #[doc = " ignore it if it doesn't resize, pick a smaller size (to satisfy"]
    #[doc = " aspect ratio or resize in steps of NxM pixels)."]
    #[doc = ""]
    #[doc = " The edges parameter provides a hint about how the surface was"]
    #[doc = " resized. The client may use this information to decide how to"]
    #[doc = " adjust its content to the new size (e.g. a scrolling area might"]
    #[doc = " adjust its content position to leave the viewable content"]
    #[doc = " unmoved)."]
    #[doc = ""]
    #[doc = " The client is free to dismiss all but the last configure event"]
    #[doc = " it received."]
    #[doc = ""]
    #[doc = " The width and height arguments specify the size of the window in"]
    #[doc = " surface-local coordinates."]
    #[doc = " @param edges how the surface was resized"]
    #[doc = " @param width new width of the surface"]
    #[doc = " @param height new height of the surface"]
    pub configure: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_shell_surface: *mut wl_shell_surface,
            edges: u32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " popup interaction is done"]
    #[doc = ""]
    #[doc = " The popup_done event is sent out when a popup grab is broken,"]
    #[doc = " that is, when the user clicks a surface that doesn't belong to"]
    #[doc = " the client owning the popup surface."]
    pub popup_done: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_shell_surface: *mut wl_shell_surface,
        ),
    >,
}
#[doc = " buffer scale value is invalid"]
pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_SCALE: wl_surface_error = 0;
#[doc = " buffer transform value is invalid"]
pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_TRANSFORM: wl_surface_error = 1;
#[doc = " @ingroup iface_wl_surface"]
#[doc = " wl_surface error values"]
#[doc = ""]
#[doc = " These errors can be emitted in response to wl_surface requests."]
pub type wl_surface_error = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_surface"]
#[doc = " @struct wl_surface_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface_listener {
    #[doc = " surface enters an output"]
    #[doc = ""]
    #[doc = " This is emitted whenever a surface's creation, movement, or"]
    #[doc = " resizing results in some part of it being within the scanout"]
    #[doc = " region of an output."]
    #[doc = ""]
    #[doc = " Note that a surface may be overlapping with zero or more"]
    #[doc = " outputs."]
    #[doc = " @param output output entered by the surface"]
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_surface: *mut wl_surface,
            output: *mut wl_output,
        ),
    >,
    #[doc = " surface leaves an output"]
    #[doc = ""]
    #[doc = " This is emitted whenever a surface's creation, movement, or"]
    #[doc = " resizing results in it no longer having any part of it within"]
    #[doc = " the scanout region of an output."]
    #[doc = " @param output output left by the surface"]
    pub leave: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_surface: *mut wl_surface,
            output: *mut wl_output,
        ),
    >,
}
#[doc = " the seat has pointer devices"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_POINTER: wl_seat_capability = 1;
#[doc = " the seat has one or more keyboards"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_KEYBOARD: wl_seat_capability = 2;
#[doc = " the seat has touch devices"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_TOUCH: wl_seat_capability = 4;
#[doc = " @ingroup iface_wl_seat"]
#[doc = " seat capability bitmask"]
#[doc = ""]
#[doc = " This is a bitmask of capabilities this seat has; if a member is"]
#[doc = " set, then it is present on the seat."]
pub type wl_seat_capability = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_seat"]
#[doc = " @struct wl_seat_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat_listener {
    #[doc = " seat capabilities changed"]
    #[doc = ""]
    #[doc = " This is emitted whenever a seat gains or loses the pointer,"]
    #[doc = " keyboard or touch capabilities. The argument is a capability"]
    #[doc = " enum containing the complete set of capabilities this seat has."]
    #[doc = ""]
    #[doc = " When the pointer capability is added, a client may create a"]
    #[doc = " wl_pointer object using the wl_seat.get_pointer request. This"]
    #[doc = " object will receive pointer events until the capability is"]
    #[doc = " removed in the future."]
    #[doc = ""]
    #[doc = " When the pointer capability is removed, a client should destroy"]
    #[doc = " the wl_pointer objects associated with the seat where the"]
    #[doc = " capability was removed, using the wl_pointer.release request. No"]
    #[doc = " further pointer events will be received on these objects."]
    #[doc = ""]
    #[doc = " In some compositors, if a seat regains the pointer capability"]
    #[doc = " and a client has a previously obtained wl_pointer object of"]
    #[doc = " version 4 or less, that object may start sending pointer events"]
    #[doc = " again. This behavior is considered a misinterpretation of the"]
    #[doc = " intended behavior and must not be relied upon by the client."]
    #[doc = " wl_pointer objects of version 5 or later must not send events if"]
    #[doc = " created before the most recent event notifying the client of an"]
    #[doc = " added pointer capability."]
    #[doc = ""]
    #[doc = " The above behavior also applies to wl_keyboard and wl_touch with"]
    #[doc = " the keyboard and touch capabilities, respectively."]
    #[doc = " @param capabilities capabilities of the seat"]
    pub capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_seat: *mut wl_seat,
            capabilities: u32,
        ),
    >,
    #[doc = " unique identifier for this seat"]
    #[doc = ""]
    #[doc = " In a multiseat configuration this can be used by the client to"]
    #[doc = " help identify which physical devices the seat represents. Based"]
    #[doc = " on the seat configuration used by the compositor."]
    #[doc = " @param name seat identifier"]
    #[doc = " @since 2"]
    pub name: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_seat: *mut wl_seat,
            name: *const ::std::os::raw::c_char,
        ),
    >,
}
#[doc = " given wl_surface has another role"]
pub const wl_pointer_error_WL_POINTER_ERROR_ROLE: wl_pointer_error = 0;
pub type wl_pointer_error = ::std::os::raw::c_uint;
#[doc = " the button is not pressed"]
pub const wl_pointer_button_state_WL_POINTER_BUTTON_STATE_RELEASED: wl_pointer_button_state = 0;
#[doc = " the button is pressed"]
pub const wl_pointer_button_state_WL_POINTER_BUTTON_STATE_PRESSED: wl_pointer_button_state = 1;
#[doc = " @ingroup iface_wl_pointer"]
#[doc = " physical button state"]
#[doc = ""]
#[doc = " Describes the physical state of a button that produced the button"]
#[doc = " event."]
pub type wl_pointer_button_state = ::std::os::raw::c_uint;
#[doc = " vertical axis"]
pub const wl_pointer_axis_WL_POINTER_AXIS_VERTICAL_SCROLL: wl_pointer_axis = 0;
#[doc = " horizontal axis"]
pub const wl_pointer_axis_WL_POINTER_AXIS_HORIZONTAL_SCROLL: wl_pointer_axis = 1;
#[doc = " @ingroup iface_wl_pointer"]
#[doc = " axis types"]
#[doc = ""]
#[doc = " Describes the axis types of scroll events."]
pub type wl_pointer_axis = ::std::os::raw::c_uint;
#[doc = " a physical wheel rotation"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_WHEEL: wl_pointer_axis_source = 0;
#[doc = " finger on a touch surface"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_FINGER: wl_pointer_axis_source = 1;
#[doc = " continuous coordinate space"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_CONTINUOUS: wl_pointer_axis_source = 2;
#[doc = " a physical wheel tilt"]
#[doc = " @since 6"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_WHEEL_TILT: wl_pointer_axis_source = 3;
#[doc = " @ingroup iface_wl_pointer"]
#[doc = " axis source types"]
#[doc = ""]
#[doc = " Describes the source types for axis events. This indicates to the"]
#[doc = " client how an axis event was physically generated; a client may"]
#[doc = " adjust the user interface accordingly. For example, scroll events"]
#[doc = " from a \"finger\" source may be in a smooth coordinate space with"]
#[doc = " kinetic scrolling whereas a \"wheel\" source may be in discrete steps"]
#[doc = " of a number of lines."]
#[doc = ""]
#[doc = " The \"continuous\" axis source is a device generating events in a"]
#[doc = " continuous coordinate space, but using something other than a"]
#[doc = " finger. One example for this source is button-based scrolling where"]
#[doc = " the vertical motion of a device is converted to scroll events while"]
#[doc = " a button is held down."]
#[doc = ""]
#[doc = " The \"wheel tilt\" axis source indicates that the actual device is a"]
#[doc = " wheel but the scroll event is not caused by a rotation but a"]
#[doc = " (usually sideways) tilt of the wheel."]
pub type wl_pointer_axis_source = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_pointer"]
#[doc = " @struct wl_pointer_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer_listener {
    #[doc = " enter event"]
    #[doc = ""]
    #[doc = " Notification that this seat's pointer is focused on a certain"]
    #[doc = " surface."]
    #[doc = ""]
    #[doc = " When a seat's focus enters a surface, the pointer image is"]
    #[doc = " undefined and a client should respond to this event by setting"]
    #[doc = " an appropriate pointer image with the set_cursor request."]
    #[doc = " @param serial serial number of the enter event"]
    #[doc = " @param surface surface entered by the pointer"]
    #[doc = " @param surface_x surface-local x coordinate"]
    #[doc = " @param surface_y surface-local y coordinate"]
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_pointer: *mut wl_pointer,
            serial: u32,
            surface: *mut wl_surface,
            surface_x: wl_fixed_t,
            surface_y: wl_fixed_t,
        ),
    >,
    #[doc = " leave event"]
    #[doc = ""]
    #[doc = " Notification that this seat's pointer is no longer focused on"]
    #[doc = " a certain surface."]
    #[doc = ""]
    #[doc = " The leave notification is sent before the enter notification for"]
    #[doc = " the new focus."]
    #[doc = " @param serial serial number of the leave event"]
    #[doc = " @param surface surface left by the pointer"]
    pub leave: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_pointer: *mut wl_pointer,
            serial: u32,
            surface: *mut wl_surface,
        ),
    >,
    #[doc = " pointer motion event"]
    #[doc = ""]
    #[doc = " Notification of pointer location change. The arguments"]
    #[doc = " surface_x and surface_y are the location relative to the focused"]
    #[doc = " surface."]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param surface_x surface-local x coordinate"]
    #[doc = " @param surface_y surface-local y coordinate"]
    pub motion: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_pointer: *mut wl_pointer,
            time: u32,
            surface_x: wl_fixed_t,
            surface_y: wl_fixed_t,
        ),
    >,
    #[doc = " pointer button event"]
    #[doc = ""]
    #[doc = " Mouse button click and release notifications."]
    #[doc = ""]
    #[doc = " The location of the click is given by the last motion or enter"]
    #[doc = " event. The time argument is a timestamp with millisecond"]
    #[doc = " granularity, with an undefined base."]
    #[doc = ""]
    #[doc = " The button is a button code as defined in the Linux kernel's"]
    #[doc = " linux/input-event-codes.h header file, e.g. BTN_LEFT."]
    #[doc = ""]
    #[doc = " Any 16-bit button code value is reserved for future additions to"]
    #[doc = " the kernel's event code list. All other button codes above"]
    #[doc = " 0xFFFF are currently undefined but may be used in future"]
    #[doc = " versions of this protocol."]
    #[doc = " @param serial serial number of the button event"]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param button button that produced the event"]
    #[doc = " @param state physical state of the button"]
    pub button: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_pointer: *mut wl_pointer,
            serial: u32,
            time: u32,
            button: u32,
            state: u32,
        ),
    >,
    #[doc = " axis event"]
    #[doc = ""]
    #[doc = " Scroll and other axis notifications."]
    #[doc = ""]
    #[doc = " For scroll events (vertical and horizontal scroll axes), the"]
    #[doc = " value parameter is the length of a vector along the specified"]
    #[doc = " axis in a coordinate space identical to those of motion events,"]
    #[doc = " representing a relative movement along the specified axis."]
    #[doc = ""]
    #[doc = " For devices that support movements non-parallel to axes multiple"]
    #[doc = " axis events will be emitted."]
    #[doc = ""]
    #[doc = " When applicable, for example for touch pads, the server can"]
    #[doc = " choose to emit scroll events where the motion vector is"]
    #[doc = " equivalent to a motion event vector."]
    #[doc = ""]
    #[doc = " When applicable, a client can transform its content relative to"]
    #[doc = " the scroll distance."]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param axis axis type"]
    #[doc = " @param value length of vector in surface-local coordinate space"]
    pub axis: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_pointer: *mut wl_pointer,
            time: u32,
            axis: u32,
            value: wl_fixed_t,
        ),
    >,
    #[doc = " end of a pointer event sequence"]
    #[doc = ""]
    #[doc = " Indicates the end of a set of events that logically belong"]
    #[doc = " together. A client is expected to accumulate the data in all"]
    #[doc = " events within the frame before proceeding."]
    #[doc = ""]
    #[doc = " All wl_pointer events before a wl_pointer.frame event belong"]
    #[doc = " logically together. For example, in a diagonal scroll motion the"]
    #[doc = " compositor will send an optional wl_pointer.axis_source event,"]
    #[doc = " two wl_pointer.axis events (horizontal and vertical) and finally"]
    #[doc = " a wl_pointer.frame event. The client may use this information to"]
    #[doc = " calculate a diagonal vector for scrolling."]
    #[doc = ""]
    #[doc = " When multiple wl_pointer.axis events occur within the same"]
    #[doc = " frame, the motion vector is the combined motion of all events."]
    #[doc = " When a wl_pointer.axis and a wl_pointer.axis_stop event occur"]
    #[doc = " within the same frame, this indicates that axis movement in one"]
    #[doc = " axis has stopped but continues in the other axis. When multiple"]
    #[doc = " wl_pointer.axis_stop events occur within the same frame, this"]
    #[doc = " indicates that these axes stopped in the same instance."]
    #[doc = ""]
    #[doc = " A wl_pointer.frame event is sent for every logical event group,"]
    #[doc = " even if the group only contains a single wl_pointer event."]
    #[doc = " Specifically, a client may get a sequence: motion, frame,"]
    #[doc = " button, frame, axis, frame, axis_stop, frame."]
    #[doc = ""]
    #[doc = " The wl_pointer.enter and wl_pointer.leave events are logical"]
    #[doc = " events generated by the compositor and not the hardware. These"]
    #[doc = " events are also grouped by a wl_pointer.frame. When a pointer"]
    #[doc = " moves from one surface to another, a compositor should group the"]
    #[doc = " wl_pointer.leave event within the same wl_pointer.frame."]
    #[doc = " However, a client must not rely on wl_pointer.leave and"]
    #[doc = " wl_pointer.enter being in the same wl_pointer.frame."]
    #[doc = " Compositor-specific policies may require the wl_pointer.leave"]
    #[doc = " and wl_pointer.enter event being split across multiple"]
    #[doc = " wl_pointer.frame groups."]
    #[doc = " @since 5"]
    pub frame: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_pointer: *mut wl_pointer),
    >,
    #[doc = " axis source event"]
    #[doc = ""]
    #[doc = " Source information for scroll and other axes."]
    #[doc = ""]
    #[doc = " This event does not occur on its own. It is sent before a"]
    #[doc = " wl_pointer.frame event and carries the source information for"]
    #[doc = " all events within that frame."]
    #[doc = ""]
    #[doc = " The source specifies how this event was generated. If the source"]
    #[doc = " is wl_pointer.axis_source.finger, a wl_pointer.axis_stop event"]
    #[doc = " will be sent when the user lifts the finger off the device."]
    #[doc = ""]
    #[doc = " If the source is wl_pointer.axis_source.wheel,"]
    #[doc = " wl_pointer.axis_source.wheel_tilt or"]
    #[doc = " wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event"]
    #[doc = " may or may not be sent. Whether a compositor sends an axis_stop"]
    #[doc = " event for these sources is hardware-specific and"]
    #[doc = " implementation-dependent; clients must not rely on receiving an"]
    #[doc = " axis_stop event for these scroll sources and should treat scroll"]
    #[doc = " sequences from these scroll sources as unterminated by default."]
    #[doc = ""]
    #[doc = " This event is optional. If the source is unknown for a"]
    #[doc = " particular axis event sequence, no event is sent. Only one"]
    #[doc = " wl_pointer.axis_source event is permitted per frame."]
    #[doc = ""]
    #[doc = " The order of wl_pointer.axis_discrete and wl_pointer.axis_source"]
    #[doc = " is not guaranteed."]
    #[doc = " @param axis_source source of the axis event"]
    #[doc = " @since 5"]
    pub axis_source: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_pointer: *mut wl_pointer,
            axis_source: u32,
        ),
    >,
    #[doc = " axis stop event"]
    #[doc = ""]
    #[doc = " Stop notification for scroll and other axes."]
    #[doc = ""]
    #[doc = " For some wl_pointer.axis_source types, a wl_pointer.axis_stop"]
    #[doc = " event is sent to notify a client that the axis sequence has"]
    #[doc = " terminated. This enables the client to implement kinetic"]
    #[doc = " scrolling. See the wl_pointer.axis_source documentation for"]
    #[doc = " information on when this event may be generated."]
    #[doc = ""]
    #[doc = " Any wl_pointer.axis events with the same axis_source after this"]
    #[doc = " event should be considered as the start of a new axis motion."]
    #[doc = ""]
    #[doc = " The timestamp is to be interpreted identical to the timestamp in"]
    #[doc = " the wl_pointer.axis event. The timestamp value may be the same"]
    #[doc = " as a preceding wl_pointer.axis event."]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param axis the axis stopped with this event"]
    #[doc = " @since 5"]
    pub axis_stop: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_pointer: *mut wl_pointer,
            time: u32,
            axis: u32,
        ),
    >,
    #[doc = " axis click event"]
    #[doc = ""]
    #[doc = " Discrete step information for scroll and other axes."]
    #[doc = ""]
    #[doc = " This event carries the axis value of the wl_pointer.axis event"]
    #[doc = " in discrete steps (e.g. mouse wheel clicks)."]
    #[doc = ""]
    #[doc = " This event does not occur on its own, it is coupled with a"]
    #[doc = " wl_pointer.axis event that represents this axis value on a"]
    #[doc = " continuous scale. The protocol guarantees that each"]
    #[doc = " axis_discrete event is always followed by exactly one axis event"]
    #[doc = " with the same axis number within the same wl_pointer.frame. Note"]
    #[doc = " that the protocol allows for other events to occur between the"]
    #[doc = " axis_discrete and its coupled axis event, including other"]
    #[doc = " axis_discrete or axis events."]
    #[doc = ""]
    #[doc = " This event is optional; continuous scrolling devices like"]
    #[doc = " two-finger scrolling on touchpads do not have discrete steps and"]
    #[doc = " do not generate this event."]
    #[doc = ""]
    #[doc = " The discrete value carries the directional information. e.g. a"]
    #[doc = " value of -2 is two steps towards the negative direction of this"]
    #[doc = " axis."]
    #[doc = ""]
    #[doc = " The axis number is identical to the axis number in the"]
    #[doc = " associated axis event."]
    #[doc = ""]
    #[doc = " The order of wl_pointer.axis_discrete and wl_pointer.axis_source"]
    #[doc = " is not guaranteed."]
    #[doc = " @param axis axis type"]
    #[doc = " @param discrete number of steps"]
    #[doc = " @since 5"]
    pub axis_discrete: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_pointer: *mut wl_pointer,
            axis: u32,
            discrete: i32,
        ),
    >,
}
#[doc = " no keymap; client must understand how to interpret the raw keycode"]
pub const wl_keyboard_keymap_format_WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP: wl_keyboard_keymap_format =
    0;
#[doc = " libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode"]
pub const wl_keyboard_keymap_format_WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1: wl_keyboard_keymap_format = 1;
#[doc = " @ingroup iface_wl_keyboard"]
#[doc = " keyboard mapping format"]
#[doc = ""]
#[doc = " This specifies the format of the keymap provided to the"]
#[doc = " client with the wl_keyboard.keymap event."]
pub type wl_keyboard_keymap_format = ::std::os::raw::c_uint;
#[doc = " key is not pressed"]
pub const wl_keyboard_key_state_WL_KEYBOARD_KEY_STATE_RELEASED: wl_keyboard_key_state = 0;
#[doc = " key is pressed"]
pub const wl_keyboard_key_state_WL_KEYBOARD_KEY_STATE_PRESSED: wl_keyboard_key_state = 1;
#[doc = " @ingroup iface_wl_keyboard"]
#[doc = " physical key state"]
#[doc = ""]
#[doc = " Describes the physical state of a key that produced the key event."]
pub type wl_keyboard_key_state = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_keyboard"]
#[doc = " @struct wl_keyboard_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard_listener {
    #[doc = " keyboard mapping"]
    #[doc = ""]
    #[doc = " This event provides a file descriptor to the client which can"]
    #[doc = " be memory-mapped to provide a keyboard mapping description."]
    #[doc = ""]
    #[doc = " From version 7 onwards, the fd must be mapped with MAP_PRIVATE"]
    #[doc = " by the recipient, as MAP_SHARED may fail."]
    #[doc = " @param format keymap format"]
    #[doc = " @param fd keymap file descriptor"]
    #[doc = " @param size keymap size, in bytes"]
    pub keymap: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_keyboard: *mut wl_keyboard,
            format: u32,
            fd: i32,
            size: u32,
        ),
    >,
    #[doc = " enter event"]
    #[doc = ""]
    #[doc = " Notification that this seat's keyboard focus is on a certain"]
    #[doc = " surface."]
    #[doc = " @param serial serial number of the enter event"]
    #[doc = " @param surface surface gaining keyboard focus"]
    #[doc = " @param keys the currently pressed keys"]
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_keyboard: *mut wl_keyboard,
            serial: u32,
            surface: *mut wl_surface,
            keys: *mut wl_array,
        ),
    >,
    #[doc = " leave event"]
    #[doc = ""]
    #[doc = " Notification that this seat's keyboard focus is no longer on a"]
    #[doc = " certain surface."]
    #[doc = ""]
    #[doc = " The leave notification is sent before the enter notification for"]
    #[doc = " the new focus."]
    #[doc = " @param serial serial number of the leave event"]
    #[doc = " @param surface surface that lost keyboard focus"]
    pub leave: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_keyboard: *mut wl_keyboard,
            serial: u32,
            surface: *mut wl_surface,
        ),
    >,
    #[doc = " key event"]
    #[doc = ""]
    #[doc = " A key was pressed or released. The time argument is a"]
    #[doc = " timestamp with millisecond granularity, with an undefined base."]
    #[doc = " @param serial serial number of the key event"]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param key key that produced the event"]
    #[doc = " @param state physical state of the key"]
    pub key: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_keyboard: *mut wl_keyboard,
            serial: u32,
            time: u32,
            key: u32,
            state: u32,
        ),
    >,
    #[doc = " modifier and group state"]
    #[doc = ""]
    #[doc = " Notifies clients that the modifier and/or group state has"]
    #[doc = " changed, and it should update its local state."]
    #[doc = " @param serial serial number of the modifiers event"]
    #[doc = " @param mods_depressed depressed modifiers"]
    #[doc = " @param mods_latched latched modifiers"]
    #[doc = " @param mods_locked locked modifiers"]
    #[doc = " @param group keyboard layout"]
    pub modifiers: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_keyboard: *mut wl_keyboard,
            serial: u32,
            mods_depressed: u32,
            mods_latched: u32,
            mods_locked: u32,
            group: u32,
        ),
    >,
    #[doc = " repeat rate and delay"]
    #[doc = ""]
    #[doc = " Informs the client about the keyboard's repeat rate and delay."]
    #[doc = ""]
    #[doc = " This event is sent as soon as the wl_keyboard object has been"]
    #[doc = " created, and is guaranteed to be received by the client before"]
    #[doc = " any key press event."]
    #[doc = ""]
    #[doc = " Negative values for either rate or delay are illegal. A rate of"]
    #[doc = " zero will disable any repeating (regardless of the value of"]
    #[doc = " delay)."]
    #[doc = ""]
    #[doc = " This event can be sent later on as well with a new value if"]
    #[doc = " necessary, so clients should continue listening for the event"]
    #[doc = " past the creation of wl_keyboard."]
    #[doc = " @param rate the rate of repeating keys in characters per second"]
    #[doc = " @param delay delay in milliseconds since key down until repeating starts"]
    #[doc = " @since 4"]
    pub repeat_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_keyboard: *mut wl_keyboard,
            rate: i32,
            delay: i32,
        ),
    >,
}
#[doc = " @ingroup iface_wl_touch"]
#[doc = " @struct wl_touch_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch_listener {
    #[doc = " touch down event and beginning of a touch sequence"]
    #[doc = ""]
    #[doc = " A new touch point has appeared on the surface. This touch"]
    #[doc = " point is assigned a unique ID. Future events from this touch"]
    #[doc = " point reference this ID. The ID ceases to be valid after a touch"]
    #[doc = " up event and may be reused in the future."]
    #[doc = " @param serial serial number of the touch down event"]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param surface surface touched"]
    #[doc = " @param id the unique ID of this touch point"]
    #[doc = " @param x surface-local x coordinate"]
    #[doc = " @param y surface-local y coordinate"]
    pub down: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_touch: *mut wl_touch,
            serial: u32,
            time: u32,
            surface: *mut wl_surface,
            id: i32,
            x: wl_fixed_t,
            y: wl_fixed_t,
        ),
    >,
    #[doc = " end of a touch event sequence"]
    #[doc = ""]
    #[doc = " The touch point has disappeared. No further events will be"]
    #[doc = " sent for this touch point and the touch point's ID is released"]
    #[doc = " and may be reused in a future touch down event."]
    #[doc = " @param serial serial number of the touch up event"]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param id the unique ID of this touch point"]
    pub up: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_touch: *mut wl_touch,
            serial: u32,
            time: u32,
            id: i32,
        ),
    >,
    #[doc = " update of touch point coordinates"]
    #[doc = ""]
    #[doc = " A touch point has changed coordinates."]
    #[doc = " @param time timestamp with millisecond granularity"]
    #[doc = " @param id the unique ID of this touch point"]
    #[doc = " @param x surface-local x coordinate"]
    #[doc = " @param y surface-local y coordinate"]
    pub motion: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_touch: *mut wl_touch,
            time: u32,
            id: i32,
            x: wl_fixed_t,
            y: wl_fixed_t,
        ),
    >,
    #[doc = " end of touch frame event"]
    #[doc = ""]
    #[doc = " Indicates the end of a set of events that logically belong"]
    #[doc = " together. A client is expected to accumulate the data in all"]
    #[doc = " events within the frame before proceeding."]
    #[doc = ""]
    #[doc = " A wl_touch.frame terminates at least one event but otherwise no"]
    #[doc = " guarantee is provided about the set of events within a frame. A"]
    #[doc = " client must assume that any state not updated in a frame is"]
    #[doc = " unchanged from the previously known state."]
    pub frame: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_touch: *mut wl_touch),
    >,
    #[doc = " touch session cancelled"]
    #[doc = ""]
    #[doc = " Sent if the compositor decides the touch stream is a global"]
    #[doc = " gesture. No further events are sent to the clients from that"]
    #[doc = " particular gesture. Touch cancellation applies to all touch"]
    #[doc = " points currently active on this client's surface. The client is"]
    #[doc = " responsible for finalizing the touch points, future touch points"]
    #[doc = " on this surface may reuse the touch point ID."]
    pub cancel: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_touch: *mut wl_touch),
    >,
    #[doc = " update shape of touch point"]
    #[doc = ""]
    #[doc = " Sent when a touchpoint has changed its shape."]
    #[doc = ""]
    #[doc = " This event does not occur on its own. It is sent before a"]
    #[doc = " wl_touch.frame event and carries the new shape information for"]
    #[doc = " any previously reported, or new touch points of that frame."]
    #[doc = ""]
    #[doc = " Other events describing the touch point such as wl_touch.down,"]
    #[doc = " wl_touch.motion or wl_touch.orientation may be sent within the"]
    #[doc = " same wl_touch.frame. A client should treat these events as a"]
    #[doc = " single logical touch point update. The order of wl_touch.shape,"]
    #[doc = " wl_touch.orientation and wl_touch.motion is not guaranteed. A"]
    #[doc = " wl_touch.down event is guaranteed to occur before the first"]
    #[doc = " wl_touch.shape event for this touch ID but both events may occur"]
    #[doc = " within the same wl_touch.frame."]
    #[doc = ""]
    #[doc = " A touchpoint shape is approximated by an ellipse through the"]
    #[doc = " major and minor axis length. The major axis length describes the"]
    #[doc = " longer diameter of the ellipse, while the minor axis length"]
    #[doc = " describes the shorter diameter. Major and minor are orthogonal"]
    #[doc = " and both are specified in surface-local coordinates. The center"]
    #[doc = " of the ellipse is always at the touchpoint location as reported"]
    #[doc = " by wl_touch.down or wl_touch.move."]
    #[doc = ""]
    #[doc = " This event is only sent by the compositor if the touch device"]
    #[doc = " supports shape reports. The client has to make reasonable"]
    #[doc = " assumptions about the shape if it did not receive this event."]
    #[doc = " @param id the unique ID of this touch point"]
    #[doc = " @param major length of the major axis in surface-local coordinates"]
    #[doc = " @param minor length of the minor axis in surface-local coordinates"]
    #[doc = " @since 6"]
    pub shape: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_touch: *mut wl_touch,
            id: i32,
            major: wl_fixed_t,
            minor: wl_fixed_t,
        ),
    >,
    #[doc = " update orientation of touch point"]
    #[doc = ""]
    #[doc = " Sent when a touchpoint has changed its orientation."]
    #[doc = ""]
    #[doc = " This event does not occur on its own. It is sent before a"]
    #[doc = " wl_touch.frame event and carries the new shape information for"]
    #[doc = " any previously reported, or new touch points of that frame."]
    #[doc = ""]
    #[doc = " Other events describing the touch point such as wl_touch.down,"]
    #[doc = " wl_touch.motion or wl_touch.shape may be sent within the same"]
    #[doc = " wl_touch.frame. A client should treat these events as a single"]
    #[doc = " logical touch point update. The order of wl_touch.shape,"]
    #[doc = " wl_touch.orientation and wl_touch.motion is not guaranteed. A"]
    #[doc = " wl_touch.down event is guaranteed to occur before the first"]
    #[doc = " wl_touch.orientation event for this touch ID but both events may"]
    #[doc = " occur within the same wl_touch.frame."]
    #[doc = ""]
    #[doc = " The orientation describes the clockwise angle of a touchpoint's"]
    #[doc = " major axis to the positive surface y-axis and is normalized to"]
    #[doc = " the -180 to +180 degree range. The granularity of orientation"]
    #[doc = " depends on the touch device, some devices only support binary"]
    #[doc = " rotation values between 0 and 90 degrees."]
    #[doc = ""]
    #[doc = " This event is only sent by the compositor if the touch device"]
    #[doc = " supports orientation reports."]
    #[doc = " @param id the unique ID of this touch point"]
    #[doc = " @param orientation angle between major axis and positive surface y-axis in degrees"]
    #[doc = " @since 6"]
    pub orientation: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_touch: *mut wl_touch,
            id: i32,
            orientation: wl_fixed_t,
        ),
    >,
}
#[doc = " unknown geometry"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
#[doc = " no geometry"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
#[doc = " horizontal RGB"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
#[doc = " horizontal BGR"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
#[doc = " vertical RGB"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
#[doc = " vertical BGR"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
#[doc = " @ingroup iface_wl_output"]
#[doc = " subpixel geometry information"]
#[doc = ""]
#[doc = " This enumeration describes how the physical"]
#[doc = " pixels on an output are laid out."]
pub type wl_output_subpixel = ::std::os::raw::c_uint;
#[doc = " no transform"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
#[doc = " 90 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
#[doc = " 180 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
#[doc = " 270 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
#[doc = " 180 degree flip around a vertical axis"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
#[doc = " flip and rotate 90 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
#[doc = " flip and rotate 180 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
#[doc = " flip and rotate 270 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
#[doc = " @ingroup iface_wl_output"]
#[doc = " transform from framebuffer to output"]
#[doc = ""]
#[doc = " This describes the transform that a compositor will apply to a"]
#[doc = " surface to compensate for the rotation or mirroring of an"]
#[doc = " output device."]
#[doc = ""]
#[doc = " The flipped values correspond to an initial flip around a"]
#[doc = " vertical axis followed by rotation."]
#[doc = ""]
#[doc = " The purpose is mainly to allow clients to render accordingly and"]
#[doc = " tell the compositor, so that for fullscreen surfaces, the"]
#[doc = " compositor will still be able to scan out directly from client"]
#[doc = " surfaces."]
pub type wl_output_transform = ::std::os::raw::c_uint;
#[doc = " indicates this is the current mode"]
pub const wl_output_mode_WL_OUTPUT_MODE_CURRENT: wl_output_mode = 1;
#[doc = " indicates this is the preferred mode"]
pub const wl_output_mode_WL_OUTPUT_MODE_PREFERRED: wl_output_mode = 2;
#[doc = " @ingroup iface_wl_output"]
#[doc = " mode information"]
#[doc = ""]
#[doc = " These flags describe properties of an output mode."]
#[doc = " They are used in the flags bitfield of the mode event."]
pub type wl_output_mode = ::std::os::raw::c_uint;
#[doc = " @ingroup iface_wl_output"]
#[doc = " @struct wl_output_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output_listener {
    #[doc = " properties of the output"]
    #[doc = ""]
    #[doc = " The geometry event describes geometric properties of the"]
    #[doc = " output. The event is sent when binding to the output object and"]
    #[doc = " whenever any of the properties change."]
    #[doc = ""]
    #[doc = " The physical size can be set to zero if it doesn't make sense"]
    #[doc = " for this output (e.g. for projectors or virtual outputs)."]
    #[doc = ""]
    #[doc = " Note: wl_output only advertises partial information about the"]
    #[doc = " output position and identification. Some compositors, for"]
    #[doc = " instance those not implementing a desktop-style output layout or"]
    #[doc = " those exposing virtual outputs, might fake this information."]
    #[doc = " Instead of using x and y, clients should use"]
    #[doc = " xdg_output.logical_position. Instead of using make and model,"]
    #[doc = " clients should use xdg_output.name and xdg_output.description."]
    #[doc = " @param x x position within the global compositor space"]
    #[doc = " @param y y position within the global compositor space"]
    #[doc = " @param physical_width width in millimeters of the output"]
    #[doc = " @param physical_height height in millimeters of the output"]
    #[doc = " @param subpixel subpixel orientation of the output"]
    #[doc = " @param make textual description of the manufacturer"]
    #[doc = " @param model textual description of the model"]
    #[doc = " @param transform transform that maps framebuffer to output"]
    pub geometry: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_output: *mut wl_output,
            x: i32,
            y: i32,
            physical_width: i32,
            physical_height: i32,
            subpixel: i32,
            make: *const ::std::os::raw::c_char,
            model: *const ::std::os::raw::c_char,
            transform: i32,
        ),
    >,
    #[doc = " advertise available modes for the output"]
    #[doc = ""]
    #[doc = " The mode event describes an available mode for the output."]
    #[doc = ""]
    #[doc = " The event is sent when binding to the output object and there"]
    #[doc = " will always be one mode, the current mode. The event is sent"]
    #[doc = " again if an output changes mode, for the mode that is now"]
    #[doc = " current. In other words, the current mode is always the last"]
    #[doc = " mode that was received with the current flag set."]
    #[doc = ""]
    #[doc = " The size of a mode is given in physical hardware units of the"]
    #[doc = " output device. This is not necessarily the same as the output"]
    #[doc = " size in the global compositor space. For instance, the output"]
    #[doc = " may be scaled, as described in wl_output.scale, or transformed,"]
    #[doc = " as described in wl_output.transform. Clients willing to retrieve"]
    #[doc = " the output size in the global compositor space should use"]
    #[doc = " xdg_output.logical_size instead."]
    #[doc = ""]
    #[doc = " The vertical refresh rate can be set to zero if it doesn't make"]
    #[doc = " sense for this output (e.g. for virtual outputs)."]
    #[doc = ""]
    #[doc = " Clients should not use the refresh rate to schedule frames."]
    #[doc = " Instead, they should use the wl_surface.frame event or the"]
    #[doc = " presentation-time protocol."]
    #[doc = ""]
    #[doc = " Note: this information is not always meaningful for all outputs."]
    #[doc = " Some compositors, such as those exposing virtual outputs, might"]
    #[doc = " fake the refresh rate or the size."]
    #[doc = " @param flags bitfield of mode flags"]
    #[doc = " @param width width of the mode in hardware units"]
    #[doc = " @param height height of the mode in hardware units"]
    #[doc = " @param refresh vertical refresh rate in mHz"]
    pub mode: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_output: *mut wl_output,
            flags: u32,
            width: i32,
            height: i32,
            refresh: i32,
        ),
    >,
    #[doc = " sent all information about output"]
    #[doc = ""]
    #[doc = " This event is sent after all other properties have been sent"]
    #[doc = " after binding to the output object and after any other property"]
    #[doc = " changes done after that. This allows changes to the output"]
    #[doc = " properties to be seen as atomic, even if they happen via"]
    #[doc = " multiple events."]
    #[doc = " @since 2"]
    pub done: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, wl_output: *mut wl_output),
    >,
    #[doc = " output scaling properties"]
    #[doc = ""]
    #[doc = " This event contains scaling geometry information that is not"]
    #[doc = " in the geometry event. It may be sent after binding the output"]
    #[doc = " object or if the output scale changes later. If it is not sent,"]
    #[doc = " the client should assume a scale of 1."]
    #[doc = ""]
    #[doc = " A scale larger than 1 means that the compositor will"]
    #[doc = " automatically scale surface buffers by this amount when"]
    #[doc = " rendering. This is used for very high resolution displays where"]
    #[doc = " applications rendering at the native resolution would be too"]
    #[doc = " small to be legible."]
    #[doc = ""]
    #[doc = " It is intended that scaling aware clients track the current"]
    #[doc = " output of a surface, and if it is on a scaled output it should"]
    #[doc = " use wl_surface.set_buffer_scale with the scale of the output."]
    #[doc = " That way the compositor can avoid scaling the surface, and the"]
    #[doc = " client can supply a higher detail image."]
    #[doc = " @param factor scaling factor of output"]
    #[doc = " @since 2"]
    pub scale: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            wl_output: *mut wl_output,
            factor: i32,
        ),
    >,
}
#[doc = " the to-be sub-surface is invalid"]
pub const wl_subcompositor_error_WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE: wl_subcompositor_error = 0;
pub type wl_subcompositor_error = ::std::os::raw::c_uint;
#[doc = " wl_surface is not a sibling or the parent"]
pub const wl_subsurface_error_WL_SUBSURFACE_ERROR_BAD_SURFACE: wl_subsurface_error = 0;
pub type wl_subsurface_error = ::std::os::raw::c_uint;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
